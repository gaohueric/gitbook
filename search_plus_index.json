{"./":{"url":"./","title":"简介","keywords":"","body":" gaohueric 天空没有痕迹 风雨已在心中 报告 bug · 请求增加功能 喜欢这个项目？请考虑捐赠来帮助它完善！ 简介 该GitBook对博客中的各个知识点进行总结归纳的。 LeetCode板块 本文将对力扣的 1-700 题中不需要会员的数据结构与算法题目进行分类，并推荐一个刷题的顺序。 对各个Tag的数据结构与算法进行总结、思考、延时，总结模板，总结常见刷题套路，记录code. leetcode 题目地址 https://leetcode-cn.com/problemset/all/ 数据库板块 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:24:26 "},"简介/数据结构与算法.html":{"url":"简介/数据结构与算法.html","title":"数据结构与算法","keywords":"","body":"LeetCode 题目分类及刷题顺序推荐 一. 数组 题目分类 题目编号 数组的遍历 485✔、495✔、414✔、628✔ 统计数组中的元素 645✔、697✔、448✔、442✔、41✔、274✔ 数组的改变、移动 453✔、665✔、283✔ 二维数组及滚动数组 118✔、119✔、661、598、419 数组的旋转 189✔、396 特定顺序遍历二维数组 54、59、498 二维数组变换 566、48、73、289 前缀和数组 303、304、238 题解 数组篇 二. 字符串 题目分类 题目编号 字符 520✔ 回文串的定义 125✔ 公共前缀 14✔ 单词 434✔、58✔ 字符串的反转 344✔、541✔、557✔、151✔ 字符的统计 387✔、389✔、383✔、242.✔、49✔、451✔、423、657✔、551✔、696、467、535✔ 数字与字符串间转换 299✔、412✔、506✔、539✔、553✔、537✔、592✔、640、38、443、8、13、12、273、165、481 子序列 392✔、524✔、521、522 高精度运算 66、67、415、43、306 字符串变换 482、6、68 字符串匹配 28、686、459、214 中心拓展法 5、647 三. 数与位 题目分类 题目编号 数字的位操作 7. 整数反转✔、9. 回文数✔、479、564、231、342、326、504、263、190、191、476、461、477、693、393、172、458、258、319、405、171、168、670、233、357、400 简单数学题 492、29、507 快速幂 50、372 四. 栈与递归 题目分类 题目编号 用栈访问最后若干元素 682、71、388 栈与计算器 150、227、224 栈与括号匹配 20、636、591、32 递归 385、341、394 五. 链表 题目分类 题目编号 链表的删除 203、237、19 链表的遍历 430 链表的旋转与反转 61、24、206、92、25 链表高精度加法 2、445 链表的合并 21、23 六. 哈希表 题目分类 题目编号 哈希表的查找、插入及删除 217、633、349、128、202、500、290、532、205、166、466、138 哈希表与索引 1、167、599、219、220 哈希表与统计 594、350、554、609、454、18 哈希表与前缀和 560、523、525 七. 贪心算法 题目分类 题目编号 数组与贪心算法 605、121、122、561、455、575、135、409、621、179、56、57、228、452、435、646、406、48、169、215、75、324、517、649、678、420 子数组与贪心算法 53、134、581、152 子序列与贪心算法 334、376、659 数字与贪心 343 单调栈法 496、503、456、316、402、321、84、85 八. 双指针法 题目分类 题目编号 头尾指针 345、680、167、15、16、18、11、42 同向双指针、滑动窗口 27、26、80、83、82、611、187、643、674、209、3、438、567、424、76、30 分段双指针 86、328、160、88、475 快慢指针 141、142、143、234、457、287 九. 树 题目分类 题目编号 树与递归 100、222、101、226、437、563、617、508、572、543、654、687、87 树的层次遍历 102、429、690、559、662、671、513、515、637、103、107、257、623、653、104、111、112、113、129、404、199、655、116、117 树的前序遍历 144、589 树的前序序列化 606、331、652、297、449 树的后序遍历 145、590 树的中序遍历与二叉搜索树 94、700、530、538、230、98、173、669、450、110、95、108、109 重构二叉树 105、106 二叉树的展开 114 最近公共祖先 235、236 Morris中序遍历 501、99 四叉树 558、427 十. 图与搜索 题目分类 题目编号 图的建立与应用 565 深度优先搜索 17、397 回溯法 526、401、36、37、51、52、77、39、216、40、46、47、31、556、60、491、78、90、79、93、332 回溯法与表达式 241、282、679 回溯法与括号 22、301 回溯法与贪心 488 广度优先搜索 133、200、695、463、542、130、417、529、127、126、433、675 并查集 547、684、685 拓扑排序 399、207、210 有限状态自动机 65、468 十一. 二分查找 题目分类 题目编号 二分查找应用(简单) 374、35、278、367、69、441 二分查找应用(中等) 34、540、275、436、300、354、658、162、4 二分查找与旋转数组 153、154、33、81 二分查找与矩阵 74、240 二分答案法 378、668、410、483 十二. 二进制运算的应用 题目分类 题目编号 异或的应用 89、136、137、260、268 与或非的应用 371、318、201 十三. 动态规划 题目分类 题目编号 数组中的动态规划 509、70、338、45、55、198、213、650、91、639、552、123、188、309、32、264、313、403 子数组、子序列中的动态规划 689、413、446、368、416、279 背包问题 322、518、474、494、377 矩阵中的动态规划 62、63、64、120、576、688、221、629、174、96、329 动态规划与字符串匹配 583、72、97、115、516、132、131、139、140、514、10、44 状态压缩动态规划 464、691、698、638、473 区间中的动态规划 486、664、375、312、546 树形dp 337、124 数位dp 233、600 十四. 数据结构 题目分类 题目编号 数据结构设计——栈与队列 225、232、284、622、641、155 数据结构设计——哈希表 676、355、380、381 数据结构设计——哈希与双向链表 432、146、460 前缀树 208、211、648、386、677、472、421、212、336、440 堆 23、373、378、632、347、692、502、630、407、295、480 树状数组 307、315、493、327、673 线段树 699 平衡树(set/map) 352、218、363 十五. 采样 题目分类 题目编号 按权值采样 528、497 蓄水池抽样 382、398 拒绝采样 470、478、519 十六. 计算几何 题目分类 题目编号 计算几何基础 593、447、223、149 分类讨论法 335 凸包 587 覆盖问题 391 十七. 常用技巧与算法 题目分类 题目编号 博弈论 292 分块 239、164 倍增法 330 拓展欧几里得算法 365 洗牌算法 384 找规律 390、672 分治法 395、667 排序算法 147、148 线性筛 204 摩尔投票法 229 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/数组.html":{"url":"简介/数组.html","title":"数组","keywords":"","body":"数组 题目分类 题目编号 数组的遍历 485✔、495✔、414✔、628✔ 统计数组中的元素 645✔、697✔、448✔、442✔、41✔、274✔ 数组的改变、移动 453✔、665✔、283✔ 二维数组及滚动数组 118✔、119✔、661、598、419 数组的旋转 189✔、396 特定顺序遍历二维数组 54、59、498 二维数组变换 566、48、73、289 前缀和数组 303、304、238 题解 数组篇 数组篇总结 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/485. 最大连续 1 的个数.html":{"url":"数组/485. 最大连续 1 的个数.html","title":"485. 最大连续 1 的个数","keywords":"","body":"485. 最大连续1的个数 //给定一个二进制数组， 计算其中最大连续1的个数。 //示例 1: //输入: [1,1,0,1,1,1] //输出: 3 //解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. // // 注意： // 输入的数组只包含 0 和1。 // 输入数组的长度是正整数，且不超过 10,000。 // // Related Topics 数组 // 👍 165 👎 0 class Solution { public int findMaxConsecutiveOnes(int[] nums) { int count = 0; int maxCount = 0; for(int i=0;imaxCount){ maxCount = count; } count = 0; } } return count>maxCount?count:maxCount; } } 思路：遍历数组，用一个计数器(count)记录1的数量，用另一个计数器记录当前1的最大出行次数，如果遇到0 ，比较count与maxCount ,maxCount 记录较大值，同时将count置为0； © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/495. 提莫攻击.html":{"url":"数组/495. 提莫攻击.html","title":"495. 提莫攻击","keywords":"","body":"495. 提莫攻击 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/414. 第三大的数.html":{"url":"数组/414. 第三大的数.html","title":"414. 第三大的数","keywords":"","body":"414. 第三大的数 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/628. 三个数的最大乘积.html":{"url":"数组/628. 三个数的最大乘积.html","title":"628. 三个数的最大乘积","keywords":"","body":"628. 三个数的最大乘积 **[terminal] //给定一个二进制数组， 计算其中最大连续1的个数。 //示例 1: //输入: [1,1,0,1,1,1] //输出: 3 //解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. // // 注意： // 输入的数组只包含 0 和1。 // 输入数组的长度是正整数，且不超过 10,000。 // // Related Topics 数组 // 👍 165 👎 0 class Solution { public int findMaxConsecutiveOnes(int[] nums) { int count = 0; int maxCount = 0; for(int i=0;imaxCount){ maxCount = count; } count = 0; } } return count>maxCount?count:maxCount; } } Info styling [info] For info Use this for infomation messages. Warning styling [warning] For warning Use this for warning messages. Danger styling [danger] For danger Use this for danger messages. Success styling [success] For info Use this for success messages. © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/645. 错误的集合.html":{"url":"数组/645. 错误的集合.html","title":"645. 错误的集合","keywords":"","body":"645. 错误的集合 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/54. 螺旋矩阵.html":{"url":"数组/54. 螺旋矩阵.html","title":"54. 螺旋矩阵","keywords":"","body":"题目描述（中等难度） [warning] 54. 螺旋矩阵 解法一：按层模拟 可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。 定义矩阵的第 kk 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。 class Solution { public List spiralOrder(int[][] matrix) { List resp = new ArrayList<>(); if(matrix.length == 0 || null == matrix){ return resp; } int left = 0; int right = matrix[0].length-1; int top = 0; int bottom = matrix.length-1; int numEle = matrix[0].length * matrix.length; while(numEle >=1){ for(int i = left ;i=1;i++){ resp.add(matrix[top][i]); numEle--; } top++; for(int i =top;i=1;i++){ resp.add(matrix[i][right]); numEle--; } right--; for(int i= right;i>=left && numEle>=1;i--){ resp.add(matrix[bottom][i]); numEle--; } bottom--; for(int i = bottom;i>=top&& numEle>=1;i--){ resp.add(matrix[i][left]); numEle--; } left++; } return resp; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/56. 合并区间.html":{"url":"数组/56. 合并区间.html","title":"56. 合并区间","keywords":"","body":"题目描述（中等难度） [warning] 56. 合并区间 解法一： © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"数组/88. 合并两个有序数组.html":{"url":"数组/88. 合并两个有序数组.html","title":"88. 合并两个有序数组","keywords":"","body":"题目描述（中等难度） 88. 合并两个有序数组 解法一：合并后排序 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int index = 0; for(int i=m;i 解法二：双指针 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = 0; int j = 0; int index = 0; int[] temp = new int[m+n]; while(i 解法三： 原地排序双指针 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i= m-1; int j = n-1; int index = m+n-1; while(i>=0 && j>=0){ if(nums1[i] > nums2[j]){ nums1[index] = nums1[i]; i--; index--; } else{ nums1[index] = nums2[j]; j--; index--; } } while(i>=0){ nums1[index] = nums1[i]; i--; index--; } while(j>=0){ nums1[index] = nums2[j]; j--; index--; } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/字符串.html":{"url":"简介/字符串.html","title":"字符串","keywords":"","body":"字符串 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"字符串/1910. 删除一个字符串中所有出现的给定子字符串.html":{"url":"字符串/1910. 删除一个字符串中所有出现的给定子字符串.html","title":"1910. 删除一个字符串中所有出现的给定子字符串","keywords":"","body":"题目描述（中等难度） [warning] 1910. 删除一个字符串中所有出现的给定子字符串 解法一： 递归 使用indexOf 获取给定字符串开始的索引， 通过substring 截断part字符串 class Solution { public String removeOccurrences(String s, String part) { if(!s.contains(part)){ return s; } int i = s.indexOf(part); s = s.substring(0, i) + s.substring(i + part.length()); return removeOccurrences(s,part); } } 也可以使用replaceFirst 将part部分替换为\"\" 效率不如方法一 class Solution { public String removeOccurrences(String s, String part) { if(!s.contains(part)){ return s; } s = s.replaceFirst(part,\"\"); return removeOccurrences(s,part); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/栈与递归.html":{"url":"简介/栈与递归.html","title":"栈与递归","keywords":"","body":"栈与递归刷题顺序 题目分类 题目编号 用栈访问最后若干元素 682、71、388 栈与计算器 150、227、224 栈与括号匹配 20、636、591、32 递归 385、341、394 栈与队列知识总结 栈的基本概念 关于“栈”，有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。后进者先出，先进者后出，这就是典型的“栈”结构。 从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。 栈在函数中的应用：栈在函数中的应用、栈在表达式中应用(括号匹配)、栈实现浏览器的前进与后退功能等 栈的实现 栈的实现主要有两种，一种是数组的实现，叫做顺序栈，另外一种是链表的实现，叫做链式栈 顺序栈 使用数组实现栈 // 功能:基于数组的顺序栈 public class ArrayStack { private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) { this.items = new String[n]; this.n = n; this.count = 0; } //功能:入栈 public boolean push(String item) { // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置 items[count] = item; //数组长度+1 ++count; //入栈成功 return true; } // 功能:出栈 public String pop() { // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素 String tmp = items[count - 1]; //数组长度-1 --count; //返回出栈数据元素 return tmp; } } 链式栈 //功能:基本链表实现栈，入栈、出栈、输出栈 public class StackBasedLinkedList { //定义栈顶指针 private Node top = null; //定义栈结点 private static class Node { //栈结点数据域 private int data; //栈结点指针域 private Node next; //构造函数 public Node(int data, Node next) { this.data = data; this.next = next; } //get 获取数据域方法 public int getData() { return data; } } public void push(int value) { //创建一个栈结点 Node newNode = new Node(value, null); // 判断栈是否为空 if (top == null) { //如果栈为空，就将入栈的值作为栈的第一个元素 top = newNode; } else { //否则插入到top栈结点前（所谓的就是单链表的头插法） newNode.next = top; top = newNode; } } //功能 : 出栈 public int pop() { // 如果栈的最顶层栈结点为null,栈为空 if (top == null) return -1; //否则执行出栈操作，现将栈顶结点的数据元素赋值给 Value int value = top.data; //将 top 指针向下移动 top = top.next; //返回出栈的值 return value; } //功能:输出栈中所有元素 public void printAll() { //将栈顶指针赋值给p Node p = top; //循环遍历栈(遍历单链表) while (p != null) { System.out.print(p.data + \" \"); //指向下一个结点 p = p.next; } } } 队列(Queue) 队列(Queue)是一种先进先出(FIFO)的数据结构，Java中定义了java.util.Queue接口用来表示队列。Java中的Queue与List、Set属于同一个级别接口，它们都是继承于Collection接口。 Java中还定义了一种双端队列java.util.Deque，我们常用的LinkedList就是实现了Deque接口。 队列的实现 Java中对于队列的实现分为非阻塞队列与阻塞队列两种 阻塞队列与普通(非阻塞)队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列. 非阻塞队列 1、LinkedList LinkedList是双相链表结构，在添加和删除元素的时具有比ArrayList更好的性能。但在Get和Set方面弱于ArrayList.当然，这些对比都是指数据量很大或者操作很频繁的情况下的对比。 当LinkedList作为队列使用时，尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 2、PriorityQueue PriorityQueue维护一个有序列表，存储到队列中的元素会按照自然顺序排列。当然，我们也可以给它指定一个实现了 java.util.Comparator 接口的排序类来指定元素排列的顺序。 3、ConcurrentLinkedQueue ConcurrentLinkedQueue看名思义，ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素并删除。 注:PriorityQueue 和 ConcurrentLinkedQueue 类在 Collection Framework中加入两个具体集合实现。 阻塞队列 阻塞队列定义在了java.util.concurrent包中，java.util.concurrent.BlockingQueue 继承了Queue接口，它有 5 个实现类，分别是 1、ArrayBlockingQueue ArrayBlockingQueue一个内部由数组支持的有界队列。初始化时必须指定队列的容量，还可以设置内部的ReentrantLock是否使用公平锁。但是公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按FIFO（先进先出）原则对元素进行排序。 它的思想就是如果BlockingQueue是空的，那么从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间才会被唤醒继续操作。 2、LinkedBlockingQueue LinkedBlockingQueue一个内部由链接节点支持的可选有界队列。初始化时不需要指定队列的容量，默认是Integer.MAX_VALUE，也可以看成容量无限大。此队列按 FIFO（先进先出）排序元素 。 3、PriorityBlockingQueue PriorityBlockingQueue一个内部由优先级堆支持的无界优先级队列。队列中的元素按优先级顺序被移除。PriorityBlockingQueue就是PriorityQueue的加锁线程安全版。 4、DelayQueue DelayQueue一个内部由优先级堆支持的、基于时间的调度队列。队列中存放Delayed元素，只有在延迟期满后才能从队列中提取元素。当一个元素的getDelay()方法返回值小于等于0时才能从队列中poll出元素，否则poll()方法会返回null。 DelayQueue是一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的Delayed 元素。 缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出；任务调度系统，能够准确的把握任务的执行时间。我们可能需要通过线程处理很多时间上要求很严格的数据。可以考虑DelayQueue。 5、SynchronousQueue SynchronousQueue它模拟的功能类似于生活中一手交钱一手交货这种情形，像那种货到付款或者先付款后发货模型不适合使用SynchronousQueue。 SynchronousQueue 也是一个队列来的，但它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"栈与递归/682. 棒球比赛.html":{"url":"栈与递归/682. 棒球比赛.html","title":"682. 棒球比赛(easy)","keywords":"","body":"题目描述（简单难度） [success] 682. 棒球比赛 解法一:Deque 双端队列实现 因为每次遇到 ++，DD，CC 时，我们需要对之前的数字进行操作，所以我们可以创建一个栈，用来存放数字。 当我们遇到数字，就压入栈，遇到符号，就对应从栈中获取数字，做出对应操作即可。 class Solution { public int calPoints(String[] ops) { int res = 0; Deque deque = new ArrayDeque<>(); for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"栈与递归/71. 简化路径.html":{"url":"栈与递归/71. 简化路径.html","title":"71. 简化路径(medium)","keywords":"","body":"题目描述（中等难度） [warning] 71. 简化路径 解法一: 栈 解题思路 分割字符串之后根据每种情况进行判定，.和``就不用管，直接跳过，..就代表着返回上一级，即弹出队尾元素（要注意判空） 其他情况直接压入队列就行。 也可以用一个数组来维护。 class Solution { public String simplifyPath(String path) { String[] pathStr = path.split(\"/\"); Deque deque = new ArrayDeque<>(); for(String s: pathStr){ if(s.equals(\"\") || s.equals(\".\")){ continue; } else if(s.equals(\"..\")){ if(!deque.isEmpty()){ deque.pollLast(); } } else{ deque.offerLast(s); } } StringBuilder sb = new StringBuilder(); for(String ans : deque){ sb.append(\"/\"); sb.append(ans); } if(sb.toString().equals(\"\")){ return \"/\"; } return sb.toString(); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"栈与递归/150. 逆波兰表达式求值.html":{"url":"栈与递归/150. 逆波兰表达式求值.html","title":"150. 逆波兰表达式求值(medium)","keywords":"","body":"题目描述（中等难度） [warning] 150. 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 解法一： 栈 思路： 解决这道题，主要是知道什么是逆波兰表达式，也就是中缀表达式。 我们先看一个例子...后缀表达式3 4 + 5 × 6 -的计算 1.从左至右扫描，将3和4压入堆栈； 2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈； 3.将5入栈； 4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 5.将6入栈； 6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 注意： 加法和减法可以不考虑顺序问题进行操作，除法和减法，是使用次顶元素进行除或者减操作 class Solution { public int evalRPN(String[] tokens) { Deque deque = new ArrayDeque<>(); for(String s : tokens){ if(s.equals(\"+\")){ deque.offerLast(deque.pollLast()+deque.pollLast()); } else if(s.equals(\"*\")){ deque.offerLast(deque.pollLast()*deque.pollLast()); } else if(s.equals(\"/\")){ int n1 = deque.pollLast(); int n2 = deque.pollLast(); deque.offerLast(n2/n1); } else if(s.equals(\"-\")){ deque.offerLast(-deque.pollLast()+deque.pollLast()); } else{ deque.offerLast(Integer.valueOf(s)); } } return deque.pollLast(); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"栈与递归/232. 用栈实现队列.html":{"url":"栈与递归/232. 用栈实现队列.html","title":"232. 用栈实现队列(easy)","keywords":"","body":"题目描述（简单难度） [success] 232. 用栈实现队列 解法一：用双栈实现队列 思路 将一个栈当作输入栈，用于压入push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。 每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。 class MyQueue { Deque inDeque; Deque outDeque; /** Initialize your data structure here. */ public MyQueue() { inDeque = new LinkedList<>(); outDeque = new LinkedList<>(); } /** Push element x to the back of queue. */ public void push(int x) { inDeque.offer(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { if(outDeque.isEmpty()){ while(!inDeque.isEmpty()){ outDeque.offer(inDeque.poll()); } } return outDeque.poll(); } /** Get the front element. */ public int peek() { if(outDeque.isEmpty()){ while(!inDeque.isEmpty()){ outDeque.offer(inDeque.poll()); } } return outDeque.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return inDeque.isEmpty() && outDeque.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/链表.html":{"url":"简介/链表.html","title":"链表","keywords":"","body":"链表 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"链表/92. 反转链表 II.html":{"url":"链表/92. 反转链表 II.html","title":"92. 反转链表 II(中等)","keywords":"","body":"题目描述（中等难度） [success] 92. 反转链表 II 解法一： 穿针引线 class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论 ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点 // 建议写在 for 循环里，语义清晰 for (int i = 0; i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"链表/19.删除链表的倒数第 N 个结点.html":{"url":"链表/19.删除链表的倒数第 N 个结点.html","title":"19.删除链表的倒数第 N 个结点(中等)","keywords":"","body":"19.删除链表的倒数第 N 个结点(中等) © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"链表/148. 排序链表.html":{"url":"链表/148. 排序链表.html","title":"148. 排序链表","keywords":"","body":"题目描述（中等难度） [warning] 148. 排序链表 解法一： 暴力，不符合空间复杂度 class Solution { List ans = new ArrayList<>(); public ListNode sortList(ListNode head) { if(head == null){ return head; } ListNode curr = head; while(curr != null){ ans.add(curr.val); curr = curr.next; } Collections.sort(ans); ListNode resp = new ListNode(-1); for(int i=0;i 解法二： 归并排序 class Solution { public ListNode sortList(ListNode head) { if(head == null || head.next == null){ return head; } ListNode midNode = middleNode(head); ListNode rightHead = midNode.next; midNode.next = null; ListNode left = sortList(head); ListNode right = sortList(rightHead); //合并两个有序链表 return mergeListNode(left,right); } public ListNode mergeListNode(ListNode left,ListNode right){ ListNode resp = new ListNode(-1); ListNode curr = resp; while(left != null && right != null){ if(left.val © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"链表/82. 删除排序链表中的重复元素 II.html":{"url":"链表/82. 删除排序链表中的重复元素 II.html","title":"82. 删除排序链表中的重复元素 II","keywords":"","body":"题目描述（中等难度） [warning] 82. 删除排序链表中的重复元素 II 解法一：暴力重组 class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null){ return head; } ListNode curr = head; Map map = new HashMap<>(); while(curr != null){ map.put(curr.val,map.getOrDefault(curr.val,0)+1); curr = curr.next; } ListNode resp = new ListNode(-1); ListNode temp = head; while(temp != null){ if(map.get(temp.val) == 1){ addNode(resp,temp.val); } temp = temp.next; } return resp.next; } public void addNode(ListNode head,Integer val){ if(head == null){ return; } ListNode curr = head; while(curr.next != null){ curr = curr.next; } ListNode node = new ListNode(val); curr.next = node; } } 优化上面代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null){ return head; } ListNode curr = head; Map map = new HashMap<>(); while(curr != null){ map.put(curr.val,map.getOrDefault(curr.val,0)+1); curr = curr.next; } ListNode dummy = new ListNode(-1); ListNode resp = dummy; ListNode temp = head; while(temp != null){ if(map.get(temp.val) == 1){ ListNode ans = new ListNode(temp.val); dummy.next = ans; dummy = dummy.next; } temp = temp.next; } return resp.next; } } 解法二：一次遍历 class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null){ return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode curr = dummy; while(curr.next != null && curr.next.next != null){ if(curr.next.val == curr.next.next.val){ int x = curr.next.val; while(curr.next != null && curr.next.val == x){ curr.next = curr.next.next; } } else{ curr = curr.next; } } return dummy.next; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"链表/25. K 个一组翻转链表.html":{"url":"链表/25. K 个一组翻转链表.html","title":"25. K 个一组翻转链表","keywords":"","body":"题目描述（中等难度） [warning] 25. K 个一组翻转链表 解法一：翻转链表 class Solution { public ListNode reverseKGroup(ListNode head, int k) { if(head == null || head.next == null){ return head; } ListNode dummy = new ListNode(-1); dummy.next = head; //初始化pre和end都指向dummy。pre指每次要翻转的链表的头结点的上一个节点。end指每次要翻转的链表的尾节点 ListNode pre = dummy; ListNode end = dummy; while(end != null){ //循环k次，找到需要翻转的链表的结尾,这里每次循环要判断end是否等于空,因为如果为空，end.next会报空指针异常。 //dummy->1->2->3->4->5 若k为2，循环2次，end指向2 for(int i=0;i2 变成2->1。 dummy->2->1 pre.next = reverse(start); //翻转后头节点变到最后。通过.next把断开的链表重新链接。 start.next = next; //将pre换成下次要翻转的链表的头结点的上一个节点。即start pre = start; //翻转结束，将end置为下次要翻转的链表的头结点的上一个节点。即start end = pre; } return dummy.next; } public ListNode reverse(ListNode head){ if(head == null || head.next == null){ return head; } ListNode curr = head; ListNode temp = null; ListNode prev = null; while(curr != null){ temp = curr.next; curr.next = prev; prev = curr; curr = temp; } return prev; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/树.html":{"url":"简介/树.html","title":"树","keywords":"","body":"树的刷题顺序 题目分类 题目编号 树与递归 100、222、101、226、437、563、617、508、572、543、654、687、87 树的层次遍历 102、429、690、559、662、671、513、515、637、103、107、257、623、653、104、111、112、113、129、404、199、655、116、117 树的前序遍历 144、589 树的前序序列化 606、331、652、297、449 树的后序遍历 145、590 树的中序遍历与二叉搜索树 94、700、530、538、230、98、173、669、450、110、95、108、109 重构二叉树 105、106 二叉树的展开 114 最近公共祖先 235、236 Morris中序遍历 501、99 四叉树 558、427 树板块知识点归纳总结 树的基本概念 树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构 关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的 节点的高度：节点到叶子节点的最长路径(边数) 节点的深度：根节点到这个节点所经历的边的个数 节点的层数：节点的深度+1 树的高度: 根节点的高度 二叉树（Binary Tree） 每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒 每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点 二叉树的性质 1.若二叉树的层次从0开始，则在二叉树的第i层至多有2^i个结点(i>=0) 2.高度为k的二叉树最多有2^(k+1) - 1个结点(k>=-1)(空树的高度为-1) 3.对任何一棵二叉树，如果其叶子结点(度为0)数为m, 度为2的结点数为n, 则m = n + 1 二叉树又分为完美二叉树、完全二叉树、完满二叉树。 完美二叉树：换句话说、只要你有孩子，你就必然是有两个孩子。 二叉树的遍历 前序遍历：(根->左->右) 对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 中序遍历 ：(左->根->右) 对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 后序遍历：(左->右->根) 对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。 实际上，二叉树的前、中、后序遍历就是一个递归的过程。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。 时间复杂度： 二叉树遍历的时间复杂度是 O(n) 递归实现二叉树的前序、中序、后序遍历 前序遍历： public void preOrderRecur(Node root) { if (root == null) { return; } System.out.print(root.data + \" -> \"); preOrderRecur(root.left); preOrderRecur(root.right); } 中序遍历： public void midOrderRecur(Node root) { if (root == null) { return; } midOrderRecur(root.left); System.out.print(root.data + \" -> \"); midOrderRecur(root.right); } 后序遍历： public void posOrderRecur(Node root) { if (root == null) { return; } posOrderRecur(root.left); posOrderRecur(root.right); System.out.print(root.data + \" -> \"); } 非递归(迭代)实现 前序、中序、后序遍历 栈实现前序遍历 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List preorderTraversal(TreeNode root) { List res = new ArrayList<>(); Deque deque = new ArrayDeque<>(); while(!deque.isEmpty() || root !=null){ while(root !=null){ res.add(root.val); deque.offerLast(root); root = root.left; } root = deque.pollLast(); root = root.right; } return res; } } 如何计算二叉树的层数 private int countLevel(TreeNode root) { if (root == null) { return 0; } return Math.max(countLevel(root.left), countLevel(root.right)) + 1; } 二叉树的层序遍历 使用队列实现层序遍历 class Solution { public static List levelOrder(TreeNode root) { Deque deque = new LinkedList<>(); deque.offer(root); List res = new ArrayList<>(); while (!deque.isEmpty()) { TreeNode levelRoot = deque.poll(); res.add(levelRoot.val); if (levelRoot.left != null) { deque.offer(levelRoot.left); } if (levelRoot.right != null) { deque.offer(levelRoot.right); } } return res; } } 构建一颗二叉树，DEBUG，看递归与迭代过程 package com.hellobike.rent.flink.etl; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Deque; import java.util.List; /** * * 3 * / \\ * 9 20 * / \\ * 15 7 * @author gaohu08299 * @create $ ID: TestTreeNode, 2021-05-08 15:55 gaohu08299 Exp $ * @since 1.0.0 */ public class TestTreeNode { public static void main(String[] args) { TreeNode t1 = new TreeNode(3); TreeNode t2 = new TreeNode(9); TreeNode t3 = new TreeNode(20); TreeNode t4 = new TreeNode(15); TreeNode t5 = new TreeNode(7); t1.left = t2; t1.right = t3; t2.left = t4; t2.right = t5; List integers = new TestTreeNode().preorderTraversal(t1); System.out.println(integers); } public List preorderTraversal(TreeNode root) { List res = new ArrayList<>(); Deque deque = new ArrayDeque<>(); while(!deque.isEmpty() || root !=null){ while(root !=null){ res.add(root.val); deque.offerLast(root); root = root.left; } root = deque.pollLast(); root = root.right; } return res; } } N叉树的层序遍历 利用队列进行广度优先搜索 关键代码 List values = new ArrayList<>(); Deque queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { Node nextNode = queue.poll(); values.add(nextNode.val); for (Node child : nextNode.children) { queue.add(child); } } 使用BFS实现的N叉树层次遍历 class Solution { public List> levelOrder(Node root) { if (null == root) { return new ArrayList<>(); } List> resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while (!deque.isEmpty()) { List ans = new ArrayList<>(); int size = deque.size(); for (int i = 0; i children = poll.children; for (Node node : children) { deque.offer(node); } //deque.addAll(poll.children); } resp.add(ans); } return resp; } } 二叉树的序列化 class Solution { List resp = new ArrayList<>(); public List preorderTraversal(TreeNode root) { if (null == root) { return new ArrayList<>(); } preOrder(root, new StringBuilder()); return resp; } public String preOrder(TreeNode root, StringBuilder sb) { if (root == null) { return \"#\"; } sb.append(root.val).append(\",\").append(preOrder(root.left, new StringBuilder())).append(\",\").append(preOrder(root.right, new StringBuilder())); resp.add(sb.toString()); return sb.toString(); } } 二叉树序列化处理子树 class Solution { Map map = new HashMap<>(); List resp = new ArrayList<>(); public List findDuplicateSubtrees(TreeNode root) { if(root == null){ return new ArrayList<>(); } preOrderSerial(root,new StringBuilder()); return resp; } public String preOrderSerial(TreeNode root,StringBuilder sb){ if(root == null){ return \"#\"; } sb.append(root.val).append(\",\").append(preOrderSerial(root.left,new StringBuilder())).append(\",\").append(preOrderSerial(root.right,new StringBuilder())); map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1); if(map.get(sb.toString()) == 2){ resp.add(root); } return sb.toString(); } } 二叉查找树 二叉查找树性质 任意节点左子树不为空，则左子树的值均小于根节点的值 任意节点右子树不为空，则右子树的值均大于根节点的值 任意节点的左右子树也分别是二叉查找树 没有键值相等的节点 局限性及应用 一个二叉查找树是由n个节点随机构成,所以，对于某些情况,二叉查找树会退化成一个有n个节点的线性链. 写树算法的模板框架 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/100. 相同的树.html":{"url":"树/100. 相同的树.html","title":"100. 相同的树(easy)","keywords":"","body":"题目描述（简单难度） [success] 100. 相同的树 解法一：遍历树 使用树的先序遍历，将遍历结果拼接，比较结果是否相同 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { StringBuilder sb = new StringBuilder(); StringBuilder sb1 = new StringBuilder(); preOrderRecur(p,sb); preOrderRecur(q,sb1); if(sb.toString().equals(sb1.toString())){ return true; } return false; } public void preOrderRecur(TreeNode root,StringBuilder sb){ if(root == null){ sb.append(\"-1\"); return; } sb.append(root.val); preOrderRecur(root.left,sb); preOrderRecur(root.right,sb); } } 解法二：深度优先搜索 如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。 如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p == null && q == null){ return true; } else if(p == null || q==null){ return false; } else if(p.val != q.val){ return false; } else{ return isSameTree(p.left,q.left) && isSameTree(p.right,q.right); } } } 解法三：广度优先搜索 总结 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/222. 完全二叉树的节点个数.html":{"url":"树/222. 完全二叉树的节点个数.html","title":"222. 完全二叉树的节点个数(medium)","keywords":"","body":"题目描述（中等难度） [warning] 222. 完全二叉树的节点个数 解法一:递归 递归遍历二叉树，统计节点个数 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int countNodes(TreeNode root) { List list = new ArrayList<>(); preOrder(root,list); return list.size(); } public void preOrder(TreeNode root,List list){ if(root == null){ return; } list.add(root.val); preOrder(root.left,list); preOrder(root.right,list); } } 简单递归实现 public int countNodes(TreeNode root) { if (root == null){ return 0; } return countNodes(root.left) + countNodes(root.right) + 1; } 解法二：迭代 使用栈进行迭代 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int countNodes(TreeNode root) { List res = new ArrayList<>(); Deque deque = new ArrayDeque<>(); while(!deque.isEmpty() || root != null){ while(root != null){ res.add(root.val); deque.offerLast(root); root = root.left; } root = deque.pollLast(); root = root.right; } return res.size(); } } 解法三：迭代+位运算 递归与迭代时间复杂度不太理想，进阶采用更快的时间复杂度解决，根据完成二叉树的性质解决问题。 完全二叉树定义：它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。 满二叉树的节点个数计算方式：层数h, 则节点个数为 2^h - 1 对 root 节点的左右子树进行高度统计，分别记为 left 和 right，有以下两种结果 left == right。这说明，左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必定已经填满了。所以左子树的节点总数我们可以直接得到，是 2^left - 1，加上当前这个 root 节点，则正好是 2^left。再对右子树进行递归统计。 left != right。说明此时最后一层不满，但倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点 +root 节点，总数为 2^right。再对左子树进行递归查找。 二叉树的层数计算方式 private int countLevel(TreeNode root) { if (root == null) { return 0; } return Math.max(countLevel(root.left), countLevel(root.right)) + 1; } 二叉树左子树或右子树层数计算 public int countLevel(TreeNode root){ int level = 0; while(root != null){ level++; root = root.left; } return level; } 注意： 1 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int countNodes(TreeNode root) { if(root == null){ return 0; } int leftLevel = level(root.left); int rightLevel = level(root.right); if(leftLevel == rightLevel){ return (int)Math.pow(2,leftLevel) + countNodes(root.right); } else{ return (int)Math.pow(2,rightLevel) + countNodes(root.left); } } public int level(TreeNode root){ int count = 0; while(root != null){ count++; root = root.left; } return count; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/101. 对称二叉树.html":{"url":"树/101. 对称二叉树.html","title":"101. 对称二叉树(easy)","keywords":"","body":"题目描述（简单难度） [success] 101. 对称二叉树 解法一：使用队列迭代方法 首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root == null){ return true; } return check(root,root); } public boolean check(TreeNode u,TreeNode v){ Deque deque = new LinkedList<>(); deque.offerLast(u); deque.offerLast(v); while(!deque.isEmpty()){ u = deque.pollFirst(); v = deque.pollFirst(); if(null == u && null == v){ continue; } if(null == u || null == v){ return false; } if(u.val != v.val){ return false; } deque.offerLast(u.left); deque.offerLast(v.right); deque.offerLast(u.right); deque.offerLast(v.left); } return true; } } 解法二：使用递归 递归结束条件： 都为空指针则返回 true 只有一个为空则返回 false 递归过程： 判断两个指针当前节点值是否相等 判断 A 的右子树与 B 的左子树是否对称 判断 A 的左子树与 B 的右子树是否对称 短路： 在递归判断过程中存在短路现象，也就是做 与 操作时，如果前面的值返回 false 则后面的不再进行计算 时间复杂度：O(n)O(n) class Solution { public boolean isSymmetric(TreeNode root) { return check(root,root); } public boolean check(TreeNode u,TreeNode v){ if(u == null && v == null){ return true; } if(u == null || v == null){ return false; } if(u.val != v.val){ return false; } return check(u.left,v.right) && check(u.right,v.left); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/226. 翻转二叉树.html":{"url":"树/226. 翻转二叉树.html","title":"226. 翻转二叉树(easy)","keywords":"","body":"题目描述（简单难度） [success] 226. 翻转二叉树 解法一： 使用递归 我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root 为根节点的整棵子树的翻转。 class Solution { public TreeNode invertTree(TreeNode root) { if(root == null){ return null; } TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root; } } 解法二： 使用队列进行 BFS 递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。 广度优先遍历需要额外的数据结构--队列，来存放临时遍历到的元素。 深度优先遍历的特点是一竿子插到底，不行了再退回来继续；而广度优先遍历的特点是层层扫荡。 所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。 对当前元素调换其左右子树的位置，然后： 判断其左子树是否为空，不为空就放入队列中 判断其右子树是否为空，不为空就放入队列中 class Solution { public TreeNode invertTree(TreeNode root) { Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ TreeNode curr = deque.poll(); if(curr == null){ continue; } TreeNode temp = curr.left; curr.left = curr.right; curr.right = temp; deque.offer(curr.left); deque.offer(curr.right); } return root; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/563. 二叉树的坡度.html":{"url":"树/563. 二叉树的坡度.html","title":"563. 二叉树的坡度(easy)","keywords":"","body":"题目描述（简单难度） [success] 563. 二叉树的坡度 解法一： 栈 解题思路： 从问题的描述中，可以清楚地了解到，我们需要在给定树的每个结点处找到其坡度，并将所有的坡度相加以获得最终结果。要找出任意结点的坡度，我们需要求出该结点的左子树上所有结点和以及其右子树上全部结点和的差值。 因此，为了找出解决方案，我们使用递归函数 traverse，在任何结点调用该函数，都会返回当前结点下面（包括其自身）的结点和。借助于任何结点的左右子结点的这一和值，我们可以直接获得该结点所对应的坡度。 class Solution { int res = 0; public int findTilt(TreeNode root) { preOrder(root); return res; } public int preOrder(TreeNode root) { if (root == null) { return 0; } int left = preOrder(root.left); int right = preOrder(root.right); res = res + Math.abs(left-right); return left + right + root.val; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/617. 合并二叉树.html":{"url":"树/617. 合并二叉树.html","title":"617. 合并二叉树(easy)","keywords":"","body":"题目描述（简单难度） [success] 617. 合并二叉树 解法一：深度优先搜索 解题思路： 可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。 两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。 如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空； 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点； 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。 对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。 class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) { return null; } if (root1 == null || root2 == null) { return root1 == null ? root2 : root1; } root1.val = root1.val + roo2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/508. 出现次数最多的子树元素和.html":{"url":"树/508. 出现次数最多的子树元素和.html","title":"508. 出现次数最多的子树元素和(medium)","keywords":"","body":"题目描述（中等难度） [warning] 508. 出现次数最多的子树元素和 解法一：使用深度优先搜索+HashMap 深度优先搜索计算出每个节点的和，存在HashMap中，HashMap统计,当前节点的值+其左子树的和+其右子树的和 class Solution { int max = 0; public int[] findFrequentTreeSum(TreeNode root) { Map map = new HashMap<>(); List list = new ArrayList<>(); getNodeVal(root,map); for (Map.Entry maps : map.entrySet()) { if(maps.getValue() == max){ list.add(maps.getKey()); } } int[] res = new int[list.size()]; for(int i=0;i map) { if (root == null) { return 0; } int left = getNodeVal(root.left, map); int right = getNodeVal(root.right, map); int ans = left + right + root.val; map.put(ans, map.getOrDefault(ans, 0) + 1); max = Math.max(max,map.get(ans)); return ans; } } 计算树节点和方法 int sum = root.val + getNodeVal(root.left) +getNodeVal(root.right); © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/572. 另一个树的子树.html":{"url":"树/572. 另一个树的子树.html","title":"572. 另一个树的子树(easy)","keywords":"","body":"题目描述（简单难度） [success] 572. 另一个树的子树 解法一： 深度优先暴力匹配 class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { //s遍历完成，还没匹配到 if(root == null){ return false; } //短路，左子树或者右子树有匹配到的就返回 return isSameTree(root,subRoot) || isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot); } //100题判断是否是同一颗树 public boolean isSameTree(TreeNode root,TreeNode subRoot){ if(root == null && subRoot == null){ return true; } if(root == null || subRoot == null){ return false; } if(root.val != subRoot.val){ return false; } return isSameTree(root.left,subRoot.left) && isSameTree(root.right,subRoot.right); } } 解法二：迭代 List保存每个树节点，取每个树节点进行判断是否与子树相等 class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { List list = new ArrayList<>(); preOrderQueue(root,list); StringBuilder sb = new StringBuilder(); preOrder(subRoot,sb); for(int i=0;i list){ if(root == null){ return; } list.add(root); preOrderQueue(root.left,list); preOrderQueue(root.right,list); } } 使用递归判断子树是否相同 class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { List list = new ArrayList<>(); preOrderQueue(root,list); for(int i=0;i list){ if(root == null){ return; } list.add(root); preOrderQueue(root.left,list); preOrderQueue(root.right,list); } public boolean isSameTree(TreeNode root,TreeNode subRoot){ if(root == null && subRoot == null){ return true; } if(root == null || subRoot == null){ return false; } if(root.val != subRoot.val){ return false; } return isSameTree(root.left,subRoot.left) && isSameTree(root.right,subRoot.right); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/543. 二叉树的直径.html":{"url":"树/543. 二叉树的直径.html","title":"543. 二叉树的直径(easy)","keywords":"","body":"题目描述（简单难度） [success] 543. 二叉树的直径 解法一： © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/654. 最大二叉树.html":{"url":"树/654. 最大二叉树.html","title":"654. 最大二叉树(medium)","keywords":"","body":"题目描述（中等难度） [warning] 654. 最大二叉树 解法一：深度优先搜索 获取数组的最大值索引，递归的保存最大值索引的值 class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return maxTree(nums,0,nums.length-1); } //递归构造最大二叉树 public TreeNode maxTree(int[] nums,int l,int r){ if(l>r){ return null; } int maxIndex = maxNumIndex(nums,l,r); TreeNode root = new TreeNode(nums[maxIndex]); root.left = maxTree(nums,l,maxIndex-1); root.right = maxTree(nums,maxIndex+1,r); return root; } //获取最大值索引 public int maxNumIndex(int[] nums,int l,int r){ Integer max = Integer.MIN_VALUE; int index = 0; for(int i=l;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/687. 最长同值路径.html":{"url":"树/687. 最长同值路径.html","title":"687. 最长同值路径(medium)","keywords":"","body":"题目描述（中等难度） [warning] 687. 最长同值路径 解法一： © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/102. 二叉树的层序遍历.html":{"url":"树/102. 二叉树的层序遍历.html","title":"102. 二叉树的层序遍历(easy)","keywords":"","body":"题目描述（简单难度） [success] 102. 二叉树的层序遍历 解法一：使用队列进行层序遍历 先巩固一下层序遍历输出 class Solution { public static void main(String[] args) { TreeNode t1 = new TreeNode(3); TreeNode t2 = new TreeNode(9); TreeNode t3 = new TreeNode(20); TreeNode t4 = new TreeNode(15); TreeNode t5 = new TreeNode(7); t1.left = t2; t1.right = t3; t2.left = t4; t2.right = t5; List resp = levelOrder(t1); resp.forEach(System.out::println); } public static List levelOrder(TreeNode root) { Deque deque = new LinkedList<>(); deque.offer(root); List res = new ArrayList<>(); while (!deque.isEmpty()) { TreeNode levelRoot = deque.poll(); res.add(levelRoot.val); if (levelRoot.left != null) { deque.offer(levelRoot.left); } if (levelRoot.right != null) { deque.offer(levelRoot.right); } } return res; } } 本题解题思路： BFS class Solution { public List> levelOrder(TreeNode root) { if (null == root) { return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offer(root); List> resp = new ArrayList<>(); while (!deque.isEmpty()) { List ans = new ArrayList<>(); int level = deque.size(); for (int i = 0; i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/429. N叉树的层序遍历.html":{"url":"树/429. N叉树的层序遍历.html","title":"429. N叉树的层序遍历(medium)","keywords":"","body":"题目描述（简单难度） [warning] 429. N 叉树的层序遍历 解法一： 广度优先搜索(BFS) 使用队列进行广度优先搜索 class Solution { public List> levelOrder(Node root) { if(null == root){ return new ArrayList<>(); } List> resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ List ans = new ArrayList<>(); int size = deque.size(); for(int i=0;i children = poll.children; for(Node node : children){ deque.offer(node); } } resp.add(ans); } return resp; } } 循环可以使用addAll进行优化 class Solution { public List> levelOrder(Node root) { if(null == root){ return new ArrayList<>(); } List> resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ List ans = new ArrayList<>(); int size = deque.size(); for(int i=0;i 解法二： 深度优先搜索(DFS) class Solution { List> resp = new ArrayList<>(); public List> levelOrder(Node root) { if(root == null){ return new ArrayList<>(); } traverseNode(root,0); return resp; } public void traverseNode(Node root,int level){ if(resp.size() ()); } resp.get(level).add(root.val); for(Node node : root.children){ traverseNode(node,level+1); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/559. N 叉树的最大深度.html":{"url":"树/559. N 叉树的最大深度.html","title":"559. N 叉树的最大深度(easy)","keywords":"","body":"题目描述（简单难度） [success] 559. N 叉树的最大深度 解法一：使用队列进行层序遍历，遍历过程中记录深度 import java.util.LinkedList; class Solution { public int maxDepth(Node root) { if(root == null){ return 0; } int res = 0; Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ int size = deque.size(); for(int i=0;i 解法二：DFS import java.util.LinkedList; class Solution { public int maxDepth(Node root) { if (root == null) { return 0; } if (root.children == null) { return 1; } int max = 0; for(Node node : root.children){ max = Math.max(max,maxDepth(node)); } return max+1; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/671. 二叉树中第二小的节点.html":{"url":"树/671. 二叉树中第二小的节点.html","title":"671. 二叉树中第二小的节点(easy)","keywords":"","body":"题目描述（简单难度） [success] 671. 二叉树中第二小的节点 解法一： DFS 使用TreeSet排序去重 保存先序遍历的值，输出第二小的数 class Solution { TreeSet treeSet = new TreeSet<>(); public int findSecondMinimumValue(TreeNode root) { if(root == null){ return -1; } preOrder(root); List list = new ArrayList<>(treeSet); if(list.size() >=2){ return list.get(1); } return -1; } public void preOrder(TreeNode root) { if (root == null) { return; } treeSet.add(root.val); preOrder(root.left); preOrder(root.right); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/513. 找树左下角的值.html":{"url":"树/513. 找树左下角的值.html","title":"513. 找树左下角的值(medium)","keywords":"","body":"题目描述（中等难度） [success] 513. 找树左下角的值 解法一：BFS 使用队列进行广度优先搜索，使用数组保存每输出的二叉树的层序遍历，访问最后一层，返回最后一层的第一个节点 class Solution { List> ans = new ArrayList<>(); public int findBottomLeftValue(TreeNode root) { if (root == null) { return -1; } levelOrder(root); if (ans.size() == 0) { return -1; } List resp = ans.get(ans.size()-1); return resp.get(0); } public void levelOrder(TreeNode root){ Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ int size = deque.size(); List list = new ArrayList<>(); for(int i=0;i 解法二：优化后的BFS 根据从右到做输出层次遍历，出队列的最后一个节点就是最左边的节点，最后一个节点无子节点，退出循环，输出结果 class Solution { public int findBottomLeftValue(TreeNode root) { if (root == null) { return -1; } Deque deque = new LinkedList<>(); deque.offer(root); TreeNode poll = new TreeNode(); while(!deque.isEmpty()){ poll = deque.poll(); if(null != poll.right){ deque.offer(poll.right); } if(null != poll.left){ deque.offer(poll.left); } } return poll.val; } } 解法二：DFS 前序遍历 比较深度 找到最大深度的第一个叶子节点 class Solution { int res = 0; int maxDepth = -1; public int findBottomLeftValue(TreeNode root) { if (root == null) { return -1; } dfs(root,0); return res; } public void dfs(TreeNode root,int depth){ if(null == root){ return; } if(depth > maxDepth){ maxDepth = depth; res = root.val; } dfs(root.left,depth+1); dfs(root.right,depth+1); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/515. 在每个树行中找最大值.html":{"url":"树/515. 在每个树行中找最大值.html","title":"515. 在每个树行中找最大值(medium)","keywords":"","body":"题目描述（中等难度） [success] 515. 在每个树行中找最大值 解法一：BFS 层序遍历 层次遍历保存每行数据，对数据排序输出最大值 class Solution { public List largestValues(TreeNode root) { if (null == root) { return new ArrayList<>(); } List resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while (!deque.isEmpty()) { int size = deque.size(); List list = new ArrayList<>(); for (int i = 0; i 上面代码优化 class Solution { public List largestValues(TreeNode root) { if (null == root) { return new ArrayList<>(); } List resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while (!deque.isEmpty()) { int size = deque.size(); int max = Integer.MIN_VALUE; for (int i = 0; i 解法二： DFS class Solution { public List largestValues(TreeNode root) { List result = new ArrayList<>(); dfs(root, 0, result);//层级从0开始，result不需要考虑加1、减1的情况 return result; } public void dfs(TreeNode root, int level, List result) { //递归DFS总结条件 if (root == null) { return; } if (result.size() == level) { result.add(level, root.val); } int max = Math.max(result.get(level), root.val); result.set(level, max); dfs(root.left, level + 1, result); dfs(root.right, level + 1, result); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/637. 二叉树的层平均值.html":{"url":"树/637. 二叉树的层平均值.html","title":"637. 二叉树的层平均值(easy)","keywords":"","body":"题目描述（简单难度） [success] 637. 二叉树的层平均值 解法一： BFS 层序遍历，对每层数据进行求和，除以每层数的个数得出结果保存 class Solution { public List averageOfLevels(TreeNode root) { if(null == root){ return new ArrayList<>(); } List resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ int size = deque.size(); Double sum = new Double(0); for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/103. 二叉树的锯齿形层序遍历.html":{"url":"树/103. 二叉树的锯齿形层序遍历.html","title":"103. 二叉树的锯齿形层序遍历(medium)","keywords":"","body":"题目描述（中等难度） [warning] 103. 二叉树的锯齿形层序遍历 解法一：BFS 使用层序遍历输出，再判断，如果是奇数层的数就不变，偶数层的数倒序输出 class Solution { public List> zigzagLevelOrder(TreeNode root) { if(null == root){ return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offer(root); int level = 0; List> resp = new ArrayList<>(); while(!deque.isEmpty()){ level++; int size = deque.size(); List list = new ArrayList<>(); for (int i = 0; i > lists = new ArrayList<>(); for(int i=0;i reverse(List list){ List resp = new ArrayList<>(); for(int i=list.size()-1;i>=0;i--){ resp.add(list.get(i)); } return resp; } } BFS优化，使用双端队列，偶数的时候就数据加在头部，奇数的时候加在尾部 class Solution { public List> zigzagLevelOrder(TreeNode root) { if (null == root) { return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offer(root); int level = 0; List> resp = new ArrayList<>(); while (!deque.isEmpty()) { level++; int size = deque.size(); Deque list = new LinkedList<>(); for (int i = 0; i (list)); } return resp; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/107. 二叉树的层序遍历 II.html":{"url":"树/107. 二叉树的层序遍历 II.html","title":"107. 二叉树的层序遍历 II(medium)","keywords":"","body":"题目描述（中等难度） [warning] 107. 二叉树的层序遍历 II 解法一：BFS 使用双端队列，每次层次遍历添加再队列头部，最后再从头部出队列 class Solution { public List> levelOrderBottom(TreeNode root) { if(null == root){ return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offer(root); Deque> ans = new LinkedList<>(); while(!deque.isEmpty()){ int size = deque.size(); List list = new ArrayList<>(); for(int i=0;i> resp = new ArrayList<>(); while(!ans.isEmpty()){ resp.add(ans.poll()); } return resp; } } 优化上面代码，使用LinkedList ,每次在头部添加元素 class Solution { public List> levelOrderBottom(TreeNode root) { if(null == root){ return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offer(root); LinkedList> ans = new LinkedList<>(); while(!deque.isEmpty()){ int size = deque.size(); List list = new ArrayList<>(); for(int i=0;i 解法二：DFS 通过深度优先搜索进行处理，首先进入的是上层，其次才是下层，并构造当前层存储容器。 为了满足自底向上的层序遍历，在每进入新一层构建当前层存储容器时，需要将存储容器插入到结果集的头部。 class Solution { List> res = new ArrayList<>(); public List> levelOrderBottom(TreeNode root) { levelOrderBottom(root, 0); return res; } public void levelOrderBottom(TreeNode root, int level) { if (root == null) return; if (res.size() ()); res.get(res.size() - level - 1).add(root.val); levelOrderBottom(root.left, level + 1); levelOrderBottom(root.right, level + 1); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/257. 二叉树的所有路径.html":{"url":"树/257. 二叉树的所有路径.html","title":"257. 二叉树的所有路径(easy)","keywords":"","body":"题目描述（简单难度） [success] 257. 二叉树的所有路径 解法一： DFS 进行dfs的时候，需要注意不要赋相同的引用。左右子树需要分别创建一个新的StringBuilder class Solution { List list = new ArrayList<>(); public List binaryTreePaths(TreeNode root) { if(null == root){ return new ArrayList<>(); } dfs(root,new StringBuilder()); return list; } public void dfs(TreeNode root,StringBuilder sb){ if(null == root){ return; } sb.append(root.val); if(null == root.left && null == root.right){ list.add(sb.toString()); } else{ sb.append(\"->\"); dfs(root.left,new StringBuilder(sb)); dfs(root.right,new StringBuilder(sb)); } } } 使用数组保存路径 class Solution { public static List> binaryTreePaths(TreeNode root) { if (root == null) { return new ArrayList<>(); } List> resp = new ArrayList<>(); List list = new ArrayList<>(); dfs(root, resp, list); return resp; } public static void dfs(TreeNode root, List> resp, List list) { if (root == null) { return; } list.add(root.val); if (root.left == null && root.right == null) { resp.add(list); } else { dfs(root.left, resp, new ArrayList<>(list)); dfs(root.right, resp, new ArrayList<>(list)); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/653. 两数之和 IV - 输入 BST.html":{"url":"树/653. 两数之和 IV - 输入 BST.html","title":"653. 两数之和 IV - 输入 BST(easy)","keywords":"","body":"题目描述（简单难度） [success] 653. 两数之和 IV - 输入 BST 解法一：DFS后求两数之和 class Solution { List list = new ArrayList<>(); public boolean findTarget(TreeNode root, int k) { if(root == null){ return false; } preOrder(root); Map map = new HashMap<>(); for(int i=0;i 优化上面代码 class Solution { Map map = new HashMap<>(); public boolean findTarget(TreeNode root, int k) { if(root == null){ return false; } return preOrder(root,k); } public boolean preOrder(TreeNode root,int k){ if(null == root){ return false; } if(map.containsKey(k-root.val)){ return true; } map.put(root.val,root.val); return preOrder(root.left,k) || preOrder(root.right,k); } } 解法二： BFS class Solution { public boolean findTarget(TreeNode root, int k) { if(root == null){ return false; } Map map = new HashMap<>(); Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ TreeNode node = deque.poll(); if(map.containsKey(k-node.val)){ return true; } map.put(node.val,node.val); if(node.left != null){ deque.offer(node.left); } if(node.right != null){ deque.offer(node.right); } } return false; } } 解法三：BST 利用BST的特性，二叉搜索树进行中序遍历，是一个有序的递增数组。 对递增数组进行双指针求两数之和 class Solution { List list = new ArrayList<>(); public boolean findTarget(TreeNode root, int k) { if (root == null) { return false; } inOrder(root); int l = 0; int r = list.size() - 1; while (l k) { r--; } else { l++; } } return false; } public void inOrder(TreeNode root){ if(root == null){ return; } inOrder(root.left); list.add(root.val); inOrder(root.right); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/104. 二叉树的最大深度.html":{"url":"树/104. 二叉树的最大深度.html","title":"104. 二叉树的最大深度(easy)","keywords":"","body":"题目描述（中等难度） [warning] 104. 二叉树的最大深度 解法一：DFS 比较左子树与右子树的最大深度 ，求二叉树深度的模板 class Solution { public int maxDepth(TreeNode root) { if(root == null){ return 0; } return preOrder(root); } public int preOrder(TreeNode root){ if(root == null){ return 0; } return Math.max(preOrder(root.left),preOrder(root.right))+1; } } 解法二：BFS 求二叉树的层次深度即可 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } int depth = 0; Deque deque = new LinkedList<>(); deque.offer(root); while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/111. 二叉树的最小深度.html":{"url":"树/111. 二叉树的最小深度.html","title":"111. 二叉树的最小深度(easy)","keywords":"","body":"题目描述（中等难度） [success] 111. 二叉树的最小深度 解法一： DFS 求最小深度时将Math.max换成Math.min即可，但要注意如果根节点的左或右子树为空的话是构不成子树的。而最小深度是要求从根节点到子树的。当左或右子树为空时，不符合要求。 class Solution { public int minDepth(TreeNode root) { if(root == null){ return 0; } if(root.left == null && root.right != null){ return minDepth(root.right)+1; } if(root.left != null && root.right == null){ return minDepth(root.left)+1; } return Math.min(minDepth(root.left),minDepth(root.right)) +1; } } 解法二：DFS求所有路径，再对路径求最小 class Solution { List> ans = new ArrayList<>(); public int minDepth(TreeNode root) { if(root == null){ return 0; } Integer min = Integer.MAX_VALUE; dfs(root,new ArrayList<>()); for(int i=0;i list = ans.get(i); min = Math.min(min,list.size()); } return min; } public void dfs(TreeNode root,List list){ if(root == null){ return; } list.add(root.val); if(root.left == null && root.right == null){ ans.add(list); } else{ dfs(root.left,new ArrayList<>(list)); dfs(root.right,new ArrayList<>(list)); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/112. 路径总和.html":{"url":"树/112. 路径总和.html","title":"112. 路径总和(easy)","keywords":"","body":"题目描述（简单难度） [success] 112. 路径总和 解法一：DFS求所有路径、再对路径求和处理 class Solution { List> resp = new ArrayList<>(); public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) { return false; } List list = new ArrayList<>(); dfs(root, list, targetSum); for (int i = 0; i ans = resp.get(i); int sum = 0; ans.stream().map for (int j = 0; j list, int targetSum) { if (null == root) { return; } list.add(root.val); if (null == root.left && null == root.right) { resp.add(list); } else { dfs(root.left, new ArrayList<>(list), targetSum); dfs(root.right, new ArrayList<>(list), targetSum); } } } 解法二： DSF 每次递归用目前值减去跟节点值，走到叶子节点判断是否已经减到0了 class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if(root == null){ return false; } if(null == root.left && null == root.right){ return targetSum - root.val == 0; } return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/113. 路径总和 II.html":{"url":"树/113. 路径总和 II.html","title":"113. 路径总和 II(easy)","keywords":"","body":"题目描述（中等难度） [warning] 113. 路径总和 II 解法一：暴力法 求出所有路径，再对路径做判断 class Solution { List> resp = new ArrayList<>(); public List> pathSum(TreeNode root, int targetSum) { if(null == root){ return new ArrayList<>(); } dfs(root,new ArrayList<>()); List> ans = new ArrayList<>(); for(int i=0;io).sum(); if(sum == targetSum){ ans.add(resp.get(i)); } } return ans; } public void dfs(TreeNode root,List list){ if(null == root){ return; } list.add(root.val); if(null == root.left && null == root.right){ resp.add(list); } else{ dfs(root.left,new ArrayList<>(list)); dfs(root.right,new ArrayList<>(list)); } } } 解法二：DFS优化 class Solution { List> resp = new ArrayList<>(); Deque deque = new LinkedList<>(); public List> pathSum(TreeNode root, int targetSum) { if(null == root){ return new ArrayList<>(); } dfs(root,targetSum); return resp; } public void dfs(TreeNode root,int targetSum){ if(null == root){ return; } deque.offerLast(root.val); if(null == root.left && null == root.right){ if(targetSum == root.val){ resp.add(new LinkedList<>(deque)); } } dfs(root.left,targetSum-root.val); dfs(root.right,targetSum-root.val); deque.pollLast(); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/129. 求根节点到叶节点数字之和.html":{"url":"树/129. 求根节点到叶节点数字之和.html","title":"129. 求根节点到叶节点数字之和(medium)","keywords":"","body":"题目描述（简单难度） [warning] 129. 求根节点到叶节点数字之和 解法一：DFS暴力破解 class Solution { List ans = new ArrayList<>(); public int sumNumbers(TreeNode root) { if(root == null){ return 0; } dfs(root,new StringBuilder()); int sum = 0; for(int i=0;i 解法二： 双百DFS class Solution { public int sumNumbers(TreeNode root) { if(null == root){ return 0; } return dfs(root,0); } public int dfs(TreeNode root,int i){ if(root == null){ return 0; } int temp = i*10+root.val; if(root.left == null && root.right == null){ return temp; } return dfs(root.left,temp) + dfs(root.right,temp); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/404. 左叶子之和.html":{"url":"树/404. 左叶子之和.html","title":"404. 左叶子之和(easy)","keywords":"","body":"题目描述（简单难度） [warning] 404. 左叶子之和 解法一：DFS class Solution { public int sumOfLeftLeaves(TreeNode root) { if(root == null){ return 0; } int sum = 0; if(root.left != null && root.left.left == null && root.left.right == null){ sum = sum + root.left.val; } return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + sum; } } 解法二：BFS 层次遍历时进行判断 class Solution { public int sumOfLeftLeaves(TreeNode root) { if(root == null){ return 0; } Deque deque = new LinkedList<>(); deque.offer(root); int sum = 0; while(!deque.isEmpty()){ TreeNode poll = deque.poll(); if(poll.left != null){ if(poll.left.left == null && poll.left.right == null){ sum = sum + poll.left.val; } deque.offer(poll.left); } if(poll.right != null){ deque.offer(poll.right); } } return sum; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/199. 二叉树的右视图.html":{"url":"树/199. 二叉树的右视图.html","title":"199. 二叉树的右视图(medium)","keywords":"","body":"题目描述（中等难度） [warning] 199. 二叉树的右视图 解法一： BFS 层次遍历 转换为保存层次遍历的最后一个节点 class Solution { public List rightSideView(TreeNode root) { if (null == root) { return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offer(root); List resp = new ArrayList<>(); while (!deque.isEmpty()) { int size = deque.size(); List list = new ArrayList<>(); for (int i = 0; i 上面代码优化，在遍历到最后一个的时候直接加到结果集中 class Solution { public List rightSideView(TreeNode root) { if(null == root){ return new ArrayList<>(); } List resp = new ArrayList<>(); Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ int size = deque.size(); for(int i=0;i 解法二：DFS class Solution { List resp = new ArrayList<>(); public List rightSideView(TreeNode root) { if(null == root){ return new ArrayList<>(); } dfs(root,0); return resp; } public void dfs(TreeNode root,int depth){ if(root == null){ return; } if(depth == resp.size()){ resp.add(root.val); } depth++; dfs(root.right,depth); dfs(root.left,depth); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/116. 填充每个节点的下一个右侧节点指针.html":{"url":"树/116. 填充每个节点的下一个右侧节点指针.html","title":"116. 填充每个节点的下一个右侧节点指针(medium)","keywords":"","body":"题目描述（中等难度） [warning] 116. 填充每个节点的下一个右侧节点指针 解法一：BFS 层次遍历，连接成链表 class Solution { public Node connect(Node root) { if(null == root){ return root; } Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ int size = deque.size(); for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/144. 二叉树的前序遍历.html":{"url":"树/144. 二叉树的前序遍历.html","title":"144. 二叉树的前序遍历(easy)","keywords":"","body":"题目描述（简单难度） [warning] 144. 二叉树的前序遍历 解法一：DFS class Solution { List resp = new ArrayList<>(); public List preorderTraversal(TreeNode root) { if(null == root){ return new ArrayList<>(); } dfs(root); return resp; } public void dfs(TreeNode root){ if(root == null){ return; } resp.add(root.val); dfs(root.left); dfs(root.right); } } 解法二： BFS class Solution { List resp = new ArrayList<>(); public List preorderTraversal(TreeNode root) { if(null == root){ return new ArrayList<>(); } Deque deque = new LinkedList<>(); while(!deque.isEmpty() || root !=null){ while(root != null){ resp.add(root.val); deque.offerFirst(root); root = root.left; } root = deque.pollFirst(); root = root.right; } return resp; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/589. N 叉树的前序遍历.html":{"url":"树/589. N 叉树的前序遍历.html","title":"589. N 叉树的前序遍历(easy)","keywords":"","body":"题目描述（简单难度） [success] 589. N 叉树的前序遍历 解法一：DFS class Solution { List resp = new ArrayList<>(); public List preorder(Node root) { if(root == null){ return resp; } dfs(root); return resp; } public void dfs(Node root){ if(root == null){ return; } resp.add(root.val); for(Node node : root.children){ dfs(node); } } } 解法二：BFS class Solution { List resp = new ArrayList<>(); public List preorder(Node root) { if(root == null){ return resp; } Deque deque = new LinkedList<>(); deque.offer(root); while(!deque.isEmpty()){ Node poll = deque.pollLast(); resp.add(poll.val); Collections.reverse(poll.children); for(Node node : poll.children){ deque.offerLast(node); } } return resp; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/606. 根据二叉树创建字符串.html":{"url":"树/606. 根据二叉树创建字符串.html","title":"606. 根据二叉树创建字符串(easy)","keywords":"","body":"题目描述（简单难度） [success] 606. 根据二叉树创建字符串 解法一：DFS class Solution { public String tree2str(TreeNode root) { if(root == null){ return null; } StringBuilder sb = new StringBuilder(); preOrder(root,sb); return sb.toString(); } public void preOrder(TreeNode root,StringBuilder sb){ if(root == null){ return; } sb.append(root.val); if(root.left != null || root.right != null){ sb.append(\"(\"); preOrder(root.left,sb); sb.append(\")\"); if(root.right != null){ sb.append(\"(\"); preOrder(root.right,sb); sb.append(\")\"); } } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/652. 寻找重复的子树.html":{"url":"树/652. 寻找重复的子树.html","title":"652. 寻找重复的子树(medium)","keywords":"","body":"题目描述（简单难度） [success] 652. 寻找重复的子树 解法一：DFS二叉树序列化 class Solution { Map map = new HashMap<>(); List resp = new ArrayList<>(); public List findDuplicateSubtrees(TreeNode root) { if(root == null){ return new ArrayList<>(); } preOrderSerial(root,new StringBuilder()); return resp; } public String preOrderSerial(TreeNode root,StringBuilder sb){ if(root == null){ return \"#\"; } sb.append(root.val).append(\",\").append(preOrderSerial(root.left,new StringBuilder())).append(\",\").append(preOrderSerial(root.right,new StringBuilder())); map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1); if(map.get(sb.toString()) == 2){ resp.add(root); } return sb.toString(); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/145. 二叉树的后序遍历.html":{"url":"树/145. 二叉树的后序遍历.html","title":"145. 二叉树的后序遍历(easy)","keywords":"","body":"题目描述（简单难度） [warning] 145. 二叉树的后序遍历 解法一：DFS class Solution { List resp = new ArrayList<>(); public List postorderTraversal(TreeNode root) { if(null == root){ return new ArrayList<>(); } dfs(root); return resp; } public void dfs(TreeNode root){ if(root == null){ return; } dfs(root.left); dfs(root.right); resp.add(root.val); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/590. N 叉树的后序遍历.html":{"url":"树/590. N 叉树的后序遍历.html","title":"590. N 叉树的后序遍历(easy)","keywords":"","body":"题目描述（简单难度） [success] 589. N 叉树的前序遍历 解法一：DFS class Solution { List resp = new ArrayList<>(); public List postorder(Node root) { if(null == root){ return new ArrayList<>(); } dfs(root); return resp; } public void dfs(Node root){ if(root == null){ return; } for(Node node : root.children){ dfs(node); } resp.add(root.val); } } class Solution { List resp = new ArrayList<>(); public List postorder(Node root) { if(null == root){ return new ArrayList<>(); } Deque deque = new LinkedList<>(); deque.offerLast(root); while(!deque.isEmpty()){ Node node = deque.pollLast(); resp.add(node.val); for(Node child : node.children){ deque.offerLast(child); } } Collections.reverse(resp); return resp; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/94. 二叉树的中序遍历.html":{"url":"树/94. 二叉树的中序遍历.html","title":"94. 二叉树的中序遍历 (easy)","keywords":"","body":"题目描述（简单难度） [success] 94. 二叉树的中序遍历 解法一：DFS class Solution { List resp = new ArrayList<>(); public List inorderTraversal(TreeNode root) { if (null == root) { return new ArrayList<>(); } middleOrder(root); return resp; } public void middleOrder(TreeNode root){ if(root == null){ return; } middleOrder(root.left); resp.add(root.val); middleOrder(root.right); } } 解法二：BFS class Solution { List resp = new ArrayList<>(); public List inorderTraversal(TreeNode root) { if (null == root) { return new ArrayList<>(); } Deque deque = new LinkedList<>(); while (!deque.isEmpty() || root != null) { while (root != null) { deque.offerLast(root); root = root.left; } root = deque.pollLast(); resp.add(root.val); root = root.right; } return resp; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/700. 二叉搜索树中的搜索.html":{"url":"树/700. 二叉搜索树中的搜索.html","title":"700. 二叉搜索树中的搜索 (easy)","keywords":"","body":"题目描述（中等难度） [success] 700. 二叉搜索树中的搜索 解法一：DFS遍历二叉树判断 class Solution { TreeNode result = null; public TreeNode searchBST(TreeNode root, int val) { if (null == root) { return null; } preOrder(root, val); return result; } public void preOrder(TreeNode root, int val) { if (root == null) { return; } preOrder(root.left, val); if (root.val == val) { result = root; return; } preOrder(root.right, val); } } 解法一：BFS遍历处理 class Solution { TreeNode result = null; public TreeNode searchBST(TreeNode root, int val) { if (null == root) { return null; } Deque deque = new LinkedList<>(); while(!deque.isEmpty() || root !=null){ while(root != null){ if(root.val == val){ result = root; } deque.offerFirst(root); root = root.left; } root = deque.pollFirst(); root = root.right; } return result; } } 解法三：DFS优化 思路：利用二叉搜索树的特性解决，二叉树中序遍历时升序的，左根右 二叉搜索树是一棵二叉树，每个节点都有以下特性： 大于左子树上任意一个节点的值， 小于右子树上任意一个节点的值。class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (root.val == val) { return root; } if (root.val > val) { return searchBST(root.left, val); } else { return searchBST(root.right, val); } } } 简化代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null || val == root.val) return root; return val © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/530. 二叉搜索树的最小绝对差.html":{"url":"树/530. 二叉搜索树的最小绝对差.html","title":"530. 二叉搜索树的最小绝对差 (easy)","keywords":"","body":"题目描述（简单难度） [success] 530. 二叉搜索树的最小绝对差 解法一：暴力破解 ，输出二叉搜索树中序遍历，再找出最小绝对差 class Solution { List ans = new ArrayList<>(); public int getMinimumDifference(TreeNode root) { if(null == root){ return 0; } dfs(root); Integer min = Integer.MAX_VALUE; for(int i=0;i 优化代码 二叉搜索树的中序遍历是升序的，相邻数存在最小绝对差，每次判断当前节点与上一节点的最小绝对差值 class Solution { Integer min = Integer.MAX_VALUE; Integer prevNode = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { if(null == root){ return 0; } int prevNode = root.val; inOrder(root); return min; } public void inOrder(TreeNode root){ if(null == root){ return; } inOrder(root.left); int temp = Math.abs(root.val-prevNode); min = Math.min(min,temp); prevNode = root.val; inOrder(root.right); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/538. 把二叉搜索树转换为累加树.html":{"url":"树/538. 把二叉搜索树转换为累加树.html","title":"538. 把二叉搜索树转换为累加树 (medium)","keywords":"","body":"题目描述（中等难度） [warning] 538. 把二叉搜索树转换为累加树 解法一：DFS 反序中序遍历 思路： 二叉搜索树的中序遍历时升序的，左根右遍历， 使用右根左进行遍历的话，得到的是一个降序的顺序。 这里使用右根左进行递归，递归过程中将节点值加起来。 class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { if (null == root) { return null; } convertBST(root.right); sum = sum + root.val; root.val = sum; convertBST(root.left); return root; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/230. 二叉搜索树中第K小的元素.html":{"url":"树/230. 二叉搜索树中第K小的元素.html","title":"230. 二叉搜索树中第K小的元素 (medium)","keywords":"","body":"题目描述（中等难度） [warning] 230. 二叉搜索树中第K小的元素 解法一：DFS暴力 class Solution { List list = new ArrayList<>(); int res = 0; public int kthSmallest(TreeNode root, int k) { if(root == null){ return 0; } inOrder(root); return list.get(k-1); } public void inOrder(TreeNode root){ if(root == null){ return; } inOrder(root.left); list.add(root.val); inOrder(root.right); } } 优化一下，提前结束 class Solution { List list = new ArrayList<>(); int res = 0; public int kthSmallest(TreeNode root, int k) { if(root == null){ return 0; } inOrder(root,k); return res; } public void inOrder(TreeNode root,int k){ if(root == null){ return; } inOrder(root.left,k); list.add(root.val); if(list.size() == k){ res = root.val; return; } inOrder(root.right,k); } } 再次优化，不使用额外空间，在递归时进行判断 class Solution { int index = 0; int res = 0; public int kthSmallest(TreeNode root, int k) { if(root == null){ return 0; } inOrder(root,k); return res; } public void inOrder(TreeNode root,int k){ if(root == null){ return; } inOrder(root.left,k); index++; if(index == k){ res = root.val; return; } inOrder(root.right,k); } } 解法二： BFS class Solution { public int kthSmallest(TreeNode root, int k) { if (root == null) { return 0; } Deque deque = new LinkedList<>(); int index = 0; while (!deque.isEmpty() || root != null) { while (root != null) { deque.offerLast(root); root = root.left; } root = deque.pollLast(); index++; if (index == k) { return root.val; } root = root.right; } return 0; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/98. 验证二叉搜索树.html":{"url":"树/98. 验证二叉搜索树.html","title":"98. 验证二叉搜索树(medium)","keywords":"","body":"题目描述（中等难度） [warning] 98. 验证二叉搜索树 解法一：DFS 利用二叉搜索树的特性，根节点总大于左子树，遍历每个节点，判断是否大于左子树， 中序遍历时升序的，判断当前节点值是否大于前一个节点值 class Solution { Long prev = Long.MIN_VALUE; boolean flag = true; public boolean isValidBST(TreeNode root) { if(root == null){ return false; } dfs(root); return flag; } public void dfs(TreeNode root){ if(root == null){ return; } dfs(root.left); if(root.val 解法二：BFS class Solution { public boolean isValidBST(TreeNode root) { if (root == null) { return false; } Deque deque = new LinkedList<>(); Long prevNum = Long.MIN_VALUE; while(!deque.isEmpty() || root != null){ while(root != null){ deque.offerLast(root); root = root.left; } root = deque.pollLast(); if(root.val © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/669. 修剪二叉搜索树.html":{"url":"树/669. 修剪二叉搜索树.html","title":"669. 修剪二叉搜索树(medium)","keywords":"","body":"题目描述（中等难度） [warning] 669. 修剪二叉搜索树 解法一： © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/110. 平衡二叉树.html":{"url":"树/110. 平衡二叉树.html","title":"110. 平衡二叉树(easy)","keywords":"","body":"题目描述（简单难度） [success] 110. 平衡二叉树 解法一：DFS 遍历过程中判断左右子树的高度差 class Solution { boolean flag = true; public boolean isBalanced(TreeNode root) { if(root == null){ return true; } dfs(root); return flag; } public void dfs(TreeNode root){ if(root == null){ return; } if(Math.abs(level(root.left)-level(root.right)) >1){ flag = false; return; } dfs(root.left); dfs(root.right); } public int level(TreeNode root) { if (root == null) { return 0; } int left = level(root.left); int right = level(root.right); return Math.max(left, right) + 1; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/108. 将有序数组转换为二叉搜索树.html":{"url":"树/108. 将有序数组转换为二叉搜索树.html","title":"108. 将有序数组转换为二叉搜索树(easy)","keywords":"","body":"题目描述（简单难度） [success] 108. 将有序数组转换为二叉搜索树 解法一：中序遍历，总是选择中间位置左边的数字作为根节点 class Solution { public TreeNode sortedArrayToBST(int[] nums) { if(null == nums || nums.length == 0){ return null; } return helper(nums,0,nums.length-1); } public TreeNode helper(int[] nums,int left,int right){ if(left>right){ return null; } int middle = (left+right)/2; TreeNode node = new TreeNode(nums[middle]); node.left = helper(nums,left,middle-1); node.right = helper(nums,middle+1,right); return node; } } 解法二：中序遍历，总是选择中间位置右边的数字作为根节点 class Solution { public TreeNode sortedArrayToBST(int[] nums) { if(null == nums || nums.length == 0){ return null; } return helper(nums,0,nums.length-1); } public TreeNode helper(int[] nums,int left,int right){ if(left>right){ return null; } int middle = (left+right+1)/2; TreeNode node = new TreeNode(nums[middle]); node.left = helper(nums,left,middle-1); node.right = helper(nums,middle+1,right); return node; } } 解法三：中序遍历，选择任意一个中间位置数字作为根节点 class Solution { Random rand = new Random(); public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length - 1); } public TreeNode helper(int[] nums, int left, int right) { if (left > right) { return null; } // 选择任意一个中间位置数字作为根节点 int mid = (left + right + rand.nextInt(2)) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = helper(nums, left, mid - 1); root.right = helper(nums, mid + 1, right); return root; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/662. 二叉树最大宽度.html":{"url":"树/662. 二叉树最大宽度.html","title":"662. 二叉树最大宽度(中等)","keywords":"","body":"题目描述（中等难度） [warning] 662. 二叉树最大宽度 解法一：BFS 二叉树的最大宽度我们可以认为是从最左边到最右边的最大距离，假如是一棵满二叉树的话，每一层的最大距离就是最左边到最右边的节点数。因为二叉树不一定都是满二叉树 我们可以这样来计算，把它想象成为一颗满二叉树，假如根节点是遍历的第1个节点，那么他的两个子节点分别是遍历的第2个和第3个节点。并且可以推算出如果一个节点是第n个遍历的，那么他的两个子节点分别是第n2和n2+1个遍历的，具体我们来画个图看一下 class Solution { public int widthOfBinaryTree(TreeNode root) { if(root == null){ return 0; } Deque deque = new LinkedList<>(); deque.offer(root); root.val = 1; int maxWidth = 0; while(!deque.isEmpty()){ int size = deque.size(); List ans = new ArrayList<>(); int left = deque.peekFirst().val; int right = deque.peekLast().val; maxWidth = Math.max(maxWidth,right-left+1); for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/236. 二叉树的最近公共祖先.html":{"url":"树/236. 二叉树的最近公共祖先.html","title":"236. 二叉树的最近公共祖先(中等)","keywords":"","body":"题目描述（简单难度） [success] 236. 二叉树的最近公共祖先 解法一：哈希表 存储父节点 思路 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。 算法 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。 class Solution { HashMap map = new HashMap<>(); Set set = new HashSet<>(); public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root); while( p != null){ set.add(p.val); p = map.get(p.val); } while(q !=null){ if(set.contains(q.val)){ return q; } q = map.get(q.val); } return null; } public void dfs(TreeNode root){ if(root == null){ return; } if(root.left != null){ map.put(root.left.val,root); dfs(root.left); } if(root.right != null){ map.put(root.right.val,root); dfs(root.right); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"树/124. 二叉树中的最大路径和.html":{"url":"树/124. 二叉树中的最大路径和.html","title":"124. 二叉树中的最大路径和(困难)","keywords":"","body":"题目描述（中等难度） [warning] 124. 二叉树中的最大路径和 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/图与搜索.html":{"url":"简介/图与搜索.html","title":"图与搜索","keywords":"","body":"图与搜索 回溯算法 什么是回溯法 回溯法也可以叫做回溯搜索法，它是一种搜索的方式，回溯是递归的副产品，只要有递归就会有回溯。 回溯法的效率 回溯法的性能如何呢，这里要和大家说清楚了，「虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法」。 「因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案」，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。 那么既然回溯法并不高效为什么还要用它呢？ 因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。 此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。 回溯法解决的问题 回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 排列问题：N个数按一定规则全排列，有几种排列方式 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 棋盘问题：N皇后，解数独等等 组合是不强调元素顺序的，排列是强调元素顺序 例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。 如何理解回溯法 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！ 因为回溯法解决的都是在集合中递归查找子集，「集合的大小就构成了树的宽度，递归的深度，都构成的树的深度」。 递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。 这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。 回溯法模板 class Solution{ void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/77. 组合.html":{"url":"图与搜索/77. 组合.html","title":"77. 组合(中等)","keywords":"","body":"题目描述（中等难度） [warning] 77. 组合 解法一：回溯 回溯算法模板 class Solution { void backtracking(参数) { if (终⽌条件){ 存放结果; return; } for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）){ 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } } class Solution { List> resp = new ArrayList<>(); Deque ans = new LinkedList<>(); public List> combine(int n, int k) { if (k (ans)); return; } for(int i=startIndex;i class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combine(int n, int k) { if (k (ans)); return; } for(int i=startIndex;i 剪支 搜索起点的上界 + 接下来要选择的元素个数 - 1 = n 搜索起点的上界 = n - (k - path.size()) + 1 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combine(int n, int k) { if(nn){ return resp; } backTracking(n,k,1); return resp; } public void backTracking(int n,int k,int startIndex){ if(ans.size() == k){ resp.add(new ArrayList<>(ans)); return; } for(int i=startIndex;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/216. 组合总和 III.html":{"url":"图与搜索/216. 组合总和 III.html","title":"216. 组合总和 III(中等)","keywords":"","body":"题目描述（中等难度） [warning] 216. 组合总和 III 解法一：回溯求出所有组合，对组合求和校验 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum3(int k, int n) { backTracking(k,n,1); return resp; } public void backTracking(int k,int n,int startIndex){ if(ans.size() == k){ int sum = ans.stream().mapToInt(o->o).sum(); if(sum == n){ resp.add(new ArrayList<>(ans)); return; } } for(int i=startIndex;i 优化上面代码 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum3(int k, int n) { backTracking(k,n,1,0); return resp; } public void backTracking(int k,int n,int startIndex,int sum){ if(ans.size() == k){ if(sum == n){ resp.add(new ArrayList<>(ans)); return; } } for(int i=startIndex;in){ break; } sum = sum + i; ans.add(i); backTracking(k,n,i+1,sum); ans.remove(ans.size()-1); sum = sum - i; } } } 解法二：优化剪支 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum3(int k, int n) { backTracking(k,n,1); return resp; } public void backTracking(int k,int n,int startIndex){ if(ans.size() == k || n (ans)); } return; } for(int i=startIndex;in){ break; } ans.add(i); backTracking(k,n-i,i+1); ans.remove(ans.size()-1); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/17. 电话号码的字母组合.html":{"url":"图与搜索/17. 电话号码的字母组合.html","title":"17. 电话号码的字母组合(中等)","keywords":"","body":"题目描述（中等难度） [warning] 17. 电话号码的字母组合 解法一：回溯 思路： 首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。 回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。 回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。 class Solution { List resp = new ArrayList<>(); StringBuilder sb = new StringBuilder(); HashMap map = new HashMap<>(); public List letterCombinations(String digits) { if (digits.length() == 0) { return resp; } map.put('0', \"\"); map.put('1', \"\"); map.put('2', \"abc\"); map.put('3', \"def\"); map.put('4', \"ghi\"); map.put('5', \"jkl\"); map.put('6', \"mno\"); map.put('7', \"pqrs\"); map.put('8', \"tuv\"); map.put('9', \"wxyz\"); backTracking(digits, 0); return resp; } public void backTracking(String digits, int index) { if (index == digits.length()) { resp.add(sb.toString()); return; } char temp = digits.charAt(index); String letter = map.get(temp); for (int i = 0; i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/39. 组合总和.html":{"url":"图与搜索/39. 组合总和.html","title":"39. 组合总和(中等)","keywords":"","body":"题目描述（中等难度） [warning] 39. 组合总和 解法一：回溯法 抽象为树型结构如下 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum(int[] candidates, int target) { backTracking(candidates,target,0); return resp; } public void backTracking(int[] candidates,int target,int sum){ if(sum > target){ return; } if(sum == target){ List list = new ArrayList<>(ans); Collections.sort(list); if(!resp.contains(list)){ resp.add(list); } return; } for(int i=0;i 优化上面代码，加入startIndex,什么时候需要加startIndex? 对单个集合求组合的时候加入startIndex class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum(int[] candidates, int target) { backTracking(candidates,target,0,0); return resp; } public void backTracking(int[] candidates,int target,int sum,int startIndex){ if(sum > target){ return; } if(sum == target){ resp.add(new ArrayList<>(ans)); return; } for(int i=startIndex;i 剪支优化 对总集合排序之后，如果下⼀层的sum（就是本层的 sum + candidates[i]）已经⼤于target，就可以 结束本轮for循环的遍历。 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum(int[] candidates, int target) { Arrays.sort(candidates); backTracking(candidates,target,0,0); return resp; } public void backTracking(int[] candidates,int target,int sum,int startIndex){ if(sum > target){ return; } if(sum == target){ resp.add(new ArrayList<>(ans)); return; } for(int i=startIndex;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/40. 组合总和 II.html":{"url":"图与搜索/40. 组合总和 II.html","title":"40. 组合总和 II(中等)","keywords":"","body":"题目描述（中等难度） [warning] 40. 组合总和 II 解法一：回溯去重 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum2(int[] candidates, int target) { backTracking(candidates,target,0,0); return resp; } public void backTracking(int[] candidates,int target,int sum,int startIndex){ if(sum > target){ return; } if(sum == target){ List temp = new ArrayList<>(ans); Collections.sort(temp); if(!resp.contains(temp)){ resp.add(temp); } return; } for(int i=startIndex;i 优化上面代码，排序去重 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backTracking(candidates,target,0,0); return resp; } public void backTracking(int[] candidates,int target,int sum,int startIndex){ if(sum > target){ return; } if(sum == target){ resp.add(new ArrayList<>(ans)); return; } for(int i=startIndex;i startIndex && candidates[i] == candidates[i-1]) continue; sum = sum + candidates[i]; ans.add(candidates[i]); backTracking(candidates,target,sum,i+1); ans.remove(ans.size()-1); sum = sum - candidates[i]; } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/131. 分割回文串.html":{"url":"图与搜索/131. 分割回文串.html","title":"131. 分割回文串(中等)","keywords":"","body":"题目描述（中等难度） [warning] 131. 分割回文串 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> partition(String s) { backTracking(s,0); return resp; } public void backTracking(String s,int startIndex){ if(startIndex >= s.length()){ resp.add(new ArrayList<>(ans)); return; } for(int i=startIndex;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/93. 复原 IP 地址.html":{"url":"图与搜索/93. 复原 IP 地址.html","title":"93. 复原 IP 地址(中等)","keywords":"","body":"题目描述（中等难度） [warning] 93. 复原 IP 地址 解法一：回溯 class Solution { List resp = new ArrayList<>(); public List restoreIpAddresses(String s) { if(s.length() > 12 || s.length() end) { return false; } if (s.charAt(start) == '0' && start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i '9' || s.charAt(i) 255) { // 如果⼤于255了不合法 return false; } } return true; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/78. 子集.html":{"url":"图与搜索/78. 子集.html","title":"78. 子集(中等)","keywords":"","body":"题目描述（中等难度） *[warning] 78. 子集 解法一： 回溯 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> subsets(int[] nums) { backTracking(nums,0); return resp; } public void backTracking(int[] nums,int startIndex){ resp.add(new ArrayList<>(ans)); if(startIndex >= nums.length){ return; } for(int i=startIndex;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/491. 递增子序列.html":{"url":"图与搜索/491. 递增子序列.html","title":"491. 递增子序列(中等)","keywords":"","body":"题目描述（中等难度） [warning] 491. 递增子序列 解法一： 回溯 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> findSubsequences(int[] nums) { if(null == nums || nums.length == 0){ return resp; } backTracking(nums,0); return resp; } public void backTracking(int[] nums,int startIndex){ List temp = new ArrayList<>(ans); if(!resp.contains(temp) && temp.size() >1 && isValid(temp)){ resp.add(temp); } if(startIndex >= nums.length){ return; } for(int i=startIndex;i list){ for(int i=1;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/46. 全排列.html":{"url":"图与搜索/46. 全排列.html","title":"46. 全排列(中等)","keywords":"","body":"题目描述（中等难度） [warning] 46. 全排列 解法一：回溯 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> permute(int[] nums) { if(null == nums || nums.length == 0){ return resp; } backTracking(nums); return resp; } public void backTracking(int[] nums){ //终止条件 if(ans.size() == nums.length){ resp.add(new ArrayList<>(ans)); return; } //处理数据 for(int i=0;i 优化上面代码，使用一个used 数组来保存访问过的元素，回溯记得标记为false class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); boolean[] used; public List> permute(int[] nums) { if(null == nums || nums.length == 0){ return resp; } used = new boolean[nums.length]; backTracking(nums); return resp; } public void backTracking(int[] nums){ if(ans.size() == nums.length){ resp.add(new ArrayList<>(ans)); return; } for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/47. 全排列 II.html":{"url":"图与搜索/47. 全排列 II.html","title":"47. 全排列 II(中等)","keywords":"","body":"题目描述（中等难度） [warning] 47. 全排列 II 解法一：回溯 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> permuteUnique(int[] nums) { if(nums == null || nums.length == 0){ return resp; } boolean[] used = new boolean[nums.length]; backTracking(nums,used); return resp; } public void backTracking(int[] nums,boolean[] used){ if(ans.size() == nums.length && !resp.contains(ans)){ resp.add(new ArrayList<>(ans)); return; } for(int i=0;i 上述代码优化 排序后去重 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> permuteUnique(int[] nums) { if(nums == null || nums.length == 0){ return resp; } Arrays.sort(nums); boolean[] used = new boolean[nums.length]; backTracking(nums,used); return resp; } public void backTracking(int[] nums,boolean[] used){ if(ans.size() == nums.length){ resp.add(new ArrayList<>(ans)); return; } for(int i=0;i 0 && nums[i] == nums[i - 1] && !used[i - 1])) { continue; } used[i] = true; ans.add(nums[i]); backTracking(nums,used); ans.remove(ans.size()-1); used[i] = false; } } } 或者 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> permuteUnique(int[] nums) { if(nums == null || nums.length == 0){ return resp; } Arrays.sort(nums); boolean[] used = new boolean[nums.length]; backTracking(nums,used); return resp; } public void backTracking(int[] nums,boolean[] used){ if(ans.size() == nums.length){ resp.add(new ArrayList<>(ans)); return; } for(int i=0;i0 && nums[i] == nums[i-1] && used[i-1] == false)){ continue; } used[i] = true; ans.add(nums[i]); backTracking(nums,used); ans.remove(ans.size()-1); used[i] = false; } } } 注意，需要先对数组进行排序处理。 排序去重。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/90. 子集 II.html":{"url":"图与搜索/90. 子集 II.html","title":"90. 子集 II(中等)","keywords":"","body":"题目描述（中等难度） *[warning] 90. 子集 II 解法一：回溯 class Solution { List> resp = new ArrayList<>(); List ans = new ArrayList<>(); public List> subsetsWithDup(int[] nums) { Arrays.sort(nums); if(null == nums || nums.length == 0){ return resp; } boolean[] used = new boolean[nums.length]; backTracking(nums,0,used); return resp; } public void backTracking(int[] nums,int startIndex,boolean[] used){ resp.add(new ArrayList<>(ans)); if(startIndex >= nums.length){ return; } for(int i=startIndex;i0 && nums[i] == nums[i-1] && used[i-1] == false)){ continue; } used[i] = true; ans.add(nums[i]); backTracking(nums,i+1,used); ans.remove(ans.size()-1); used[i] = false; } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/332. 重新安排行程.html":{"url":"图与搜索/332. 重新安排行程.html","title":"332. 重新安排行程(中等)","keywords":"","body":"题目描述（中等难度） *[warning] 332. 重新安排行程 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"图与搜索/51. N 皇后.html":{"url":"图与搜索/51. N 皇后.html","title":"51. N 皇后(中等)","keywords":"","body":"题目描述（中等难度） [warning] 51. N 皇后 解法一: class Solution { List> resp = new ArrayList<>(); public List> solveNQueens(int n) { char[][] chessboard = new char[n][n]; for(char[] c : chessboard){ Arrays.fill(c,'.'); } backTracking(n,chessboard,0); return resp; } public void backTracking(int n,char[][] chessboard,int row){ if(row == n){ List temp = new ArrayList<>(); for(char[] c: chessboard){ temp.add(String.valueOf(c)); } resp.add(temp); return; } for(int col=0;col=0&&j>=0;i--,j--){ if(chessboard[i][j] == 'Q'){ return false; } } for(int i=row-1,j=col+1;i>=0&&j © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/二分查找.html":{"url":"简介/二分查找.html","title":"二分查找","keywords":"","body":"二分查找 二分查找的刷题顺序 题目分类 题目编号 二分查找应用(简单) 374、35、278、367、69、441 二分查找应用(中等) 34、540、275、436、300、354、658、162、4 二分查找与旋转数组 153、154、33、81 二分查找与矩阵 74、240 二分答案法 378、668、410、483 二分查找的基本问题 二分查找的基本问题是「力扣」第 704 题：二分查找。 class Solution { public int search(int[] nums, int target) { int len = nums.length; int left = 0; int right = len - 1; // 在 [left..right] 里查找 target while (left target) { // 下一轮搜索区间：[left..mid - 1] right = mid - 1; } else { // 此时：nums[mid] 说明： 二分查找的思路是：根据待搜索区间里的中间元素 nums[mid] 与 target 的值的大小关系，判断下一轮搜索需要在哪个区间里查找，进而设置 left 和 right 的值。分为如下三种情况： 如果 nums[mid] == target，运气很好，找到了目标元素，返回 mid ； 如果 nums[mid] > target，说明 mid 以及 mid 的 右边 的所有元素一定都比 target 大，下一轮搜索需要在区间 [left..mid - 1] 里查找，此时设置 right = mid - 1； 如果 nums[mid] 2. 二分查找的问题变种 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素 查找第一个值等于给定值的元素 当查到到的时候，判断左边元素是否等于给定值，如果不等于，当前值就是查找到的第一个值，同时判断middle是否等于0，如果等于第一个，直接返回 class Solution{ public int findFirst(int[] nums,int target){ int low = 0; int high = nums.length-1; while(low> 1); if(nums[middle] > target){ high = middle-1; } else if(nums[middle] 查找最后一个值等于给定值的元素 当查到到的时候，判断右边元素是否等于给定值，如果不等于，当前值就是查找到的最后一个值，同时判断middle是否等于nums.length-1，如果等于最后一个元素，直接返回 class Solution{ public int findLast(int[] nums,int target){ int low = 0; int high = nums.length-1; while(low target){ high = middle-1; } else if(nums[middle] 查找第一个大于等于给定值的元素 class Solution{ public int bsearch(int[] a, int n, int value) { int low = 0; int high = n - 1; while (low > 1); if (a[mid] >= value) { if ((mid == 0) || (a[mid - 1] 查找最后一个小于等于给定值的元素 class Solution{ public int bsearch7(int[] a, int n, int value) { int low = 0; int high = n - 1; while (low > 1); if (a[mid] > value) { high = mid - 1; } else { if ((mid == n - 1) || (a[mid + 1] > value)) return mid; else low = mid + 1; } } return -1; } } 这样的问题有一个特点：当看到了 nums[mid] 恰好等于 target 的时候，还得继续查找，继续看看左边的元素的值，或者继续看看右边元素的值。如果不小心，很可能逻辑写错。如果还用「1. 二分查找的基本问题」介绍的方式编写代码，就没有那么容易： while 里面的 if 、else 该怎么写，有没有什么固定的思路？ 退出循环以后，right 在左，left 在右，返回 left 还是 right 需要分类讨论。 本题解要介绍的「二分查找」的思想其实不是什么新鲜的事儿。如下图所示，它像极了「双指针」算法，left 和 right 向中间走，直到它们重合在一起。 这种二分查找的思考路径，不是我发明的（「参考资料」在题解最后）。我一开始看到这种写法也觉得很惊讶，也搞不明白到底怎么回事，但是我看到的解释就只有「这是模板」，但没有看到为什么有这个模板。因此我 尝试去了解它，并使用它，然后整理成这篇题解。用这种二分查找的思路，可以解决「力扣」上 所有的 「二分查找」问题。 3. 把待搜索区间分成两个部分（重点、最重要的部分在这里） 根据看到的中间位置的元素的值 nums[mid] 可以把待搜索区间分为两个部分： 一定不存在 目标元素的区间：下一轮搜索的时候，不用考虑它； 可能存在 目标元素的区间：下一轮搜索的时候，需要考虑它。 由于 mid 只可能被分到这两个区间的其中一个，即：while 里面的 if 和 else 就两种写法： 如果 mid 分到左边区间，即区间分成 [left..mid] 与 [mid + 1..right]，此时分别设置 right = mid 与 left = mid + 1； 如果 mid 分到右边区间，即区间分成 [left..mid - 1] 与 [mid..right]，此时分别设置 right = mid - 1 与 left = mid。 并且把 循环可以继续的条件 写成 while (left 这里介绍一个 「重要的经验」： 在 写 if 语句的时候，通常把容易想到的，不容易出错的逻辑写在 if 的里面，这样就把复杂的、容易出错的情况放在了 else 的部分，这样编写代码不容易出错。 什么情况是容易想到的，不容易出错的呢？我的经验是：题目要我们找符合条件 a 的元素，我们就对条件 a 取反面，这样分析不容易出错。 例如本题（「力扣」第 35 题），题目要我们找出第一个大于等于 target 的元素的下标，那么小于 target 的元素就一定不是我们要找的。因此 if 语句就是 if (nums[mid] 剩下的情况放在 else 中，我们 甚至可以不用分析 else 是什么情况。if 的区间是 [mid + 1..right]，它的反面区间就是 [left..mid]，此时 else 就应该设置 right = mid。 因此完整的逻辑就是： if (nums[mid] 上面的叙述，总结起来就一句话：我们 总是在区间 [left..right] 里查找元素目标。 注意：我们说的是 左闭右闭区间。为什么不是「左闭右开」呢？「左闭右开」当然可以，但是我们 不想把精力花在思考「右边界是不是可以取到」这件事情上，这是因为 任意一个「左闭右开 [left..right) 」区间一定唯一对应一个「左闭右闭 [left..right - 1]」区间，所以到底是开区间还是闭区间，前后保持一致就可以。 根据 mid 位置是不是目标元素，进而判断 mid 的左边是否存在目标元素，mid 的右边是否存在目标元素，只把搜索区间分为两个部分，然后设置 left 和 right，在设置 left 和 right 的时候，左闭右闭区间的形式是最直观的，这是因为如果是开区间，还需要在脑子里反应一下，右端点不包括。如果我们觉得二分问题复杂，复杂问题应该简单做 我们再说说把区间分成两个部分的好处： 在代码层面，只可能有以下两种情况： while(left while(left 只有在这两种把区间分成两个部分的划分下，退出循环以后有 left == right 成立，我们不用去讨论返回 left 还是 right（这句话非常重要，大家可以在做题的过程中慢慢体会） 补充说明：有的朋友觉得把区间分为三个部分更清晰，但是一旦分成三个部分，有 mid + 1、mid - 1 出现，退出循环以后就不一定有 left 和 right 重合。我们完全可以这样做，分类讨论的时候分成三个部分，然后把它们的逻辑合并起来。 在我们的讲解中 while(left 至于为什么是 left = mid + 1 、 right = mid 搭配使用，而 left = mid 、 right = mid - 1 搭配使用，这一点完全不用记忆，我们画图说明。 因此我们再次和大家强调：永远去思考下一轮搜索应该在哪个区间里，就能考虑清楚到底下一轮更新的是 left 还是 right ，到底加不加 1，到底减不减 1。 4. 例题讲解：「力扣」第 35 题：搜索插入位置 思路分析： 根据示例 3： 输入: [1, 3, 5, 6], 7 输出: 4 如果目标元素大于输入数组中的最后一个元素，返回数组的最后一个元素的下标 + 1。 根据示例 2 输入: [1,3,5,6], 2 输出: 1 需要返回第 1 个 大于等于（等于的情况可以看示例 1，这里省略） 目标元素 2 的下标，因此输出 1。因此 如果当前 mid 看到的数值严格小于 target，那么 mid 以及 mid 左边的所有元素就一定不是题目要求的输出，就根据这一点可以写出本题二分查找算法的完整逻辑。 public class Solution { public int searchInsert(int[] nums, int target) { int len = nums.length; // 特殊判断 if (nums[len - 1] 值得一提的是：由于执行到最后 nums[left..right] 里一定存在插入元素的位置，并且退出循环的时候一定有 left == right 成立，因此直接返回 left 或者 right 均可。 这样的思路还可以完成第 704 题。 class Solution { public int search(int[] nums, int target) { int len = nums.length; int left = 0; int right = len - 1; // 在 nums[left..right] 里查找 target while (left 退出循环的时候，我们不能确定 nums[left] 是否等于 target，因此还需要单独做一次判断； 「选项卡二」我们还给出了一版代码，具体细节大家可以在阅读完本题解以后再来理解它。 5. 两种写法对比 写法 1： while(left 程序开始的时候，我们对输入数组一无所知。 我们选择 nums[mid] 的值看一下。 如果中间位置的元素的值等于目标元素就直接返回。如果中间位置的元素不是目标元素，可以根据中间位置元素的值决定在中间位置的左边还是右边继续查找。这种查找方式把待搜索区间分为三个部分：左、中、右。 重要经验：如果我们要找的元素性质非常明确、并且简单，通常这样写就可以。例如「力扣」第 704 题（二分查找），第 633 题（平方数之和）。 写法 2：while(left 这种思路可以很形象地理解为「两边夹」，在解决复杂问题的时候，会使得思考的过程变得简单。 程序开始的时候，我们对输入数组一无所知。 我们选择 nums[mid] 的值看一下。 然后我们只分析：在什么情况下，目标元素位于哪个区间里，把区间分成「一定不存在目标元素的区间」和「可能存在目标元素的区间」。而 mid 只可能位于这两个区间的其中一个，可以分为下面 4 种情况。 虽然看起来比较多，但是归结起来就 2 种情况：mid 在左边区间和 mid 在右边区间。即：根据 mid 的值，可以判断 nums[mid] 是「一定不是目标元素」还是「有可能是目标元素」，进而判断 mid 的左右两边的区间的性质。 重要经验： 如果我们要找的元素的性质比较复杂：例如需要满足「条件 1」并且「条件 2」。我们在编写 if 语句的时候，就可以把其中一个条件取反，就可以达到缩减搜索区间的目的。 这一点也不难想明白，「条件 1」并且「条件 2」的反面就是「取反条件 1」或者「取反条件 2」。再举一个具体的例子：例如我们要找一个数 xx，需要满足 4 \\le x \\le 94≤x≤9，即 x \\ge 4x≥4 并且 x \\le 9x≤9。如果我们看到一个数小于 44，我们就知道此时需要在当前位置的右边继续查找，可以得到缩减问题区间的目的。 「力扣」第 4 题（寻找两个正序数组的中位数）的 视频题解，我们详细介绍了用这种思路分析问题的方法，并给出了 2 版等价的代码。 6. 一些细节（以问答形式呈现） 细节一：为什么有些时候取 mid 的时候需要上取整？ 回答：是否需要上取整，只和区间划分的逻辑有关。如果不调整，会出现死循环。 初次接触的时候，很多朋友觉得这件事情非常难以理解，我们的建议是：一旦遇到死循环，可以在程序中输出 left、right 和 mid 的值看一下就很清楚了。「力扣」第 69 题：x 的平方根 的 题解 ，我们演示了如何打印变量、观察到死循环。 结论：当区间只剩下两个元素的时候，left = mid 和 right = mid - 1 这种划分方式，如果 mid 使用默认下取整的方式，在数值上 left = mid，而它对应的其中一个区间是 [mid..right]，在这种情况下，下一轮搜索区间还是 [left..right]，搜索区间没有减少，会进入死循环。 提示：「看到边界设置的代码是 left = mid 时，需要把 mid 的取法调整为上取整，以避免死循环」，这件事情也完全不用记忆，题目做得多了，自然而然就记住了。还是我们在题解中和大家多次强调的一件事情：遇到代码出错的时候，一定要耐心调试，把变量打印出来看一下，是最好的学习的方法。 细节二：有些学习资料上说 while (left 回答：区间的右端点到底是开还是闭，完全由编写代码的人决定，不需要固定。只要编码的人逻辑前后一致，并且保持不变（这件事情叫遵守「循环不变量」），就是正确的。 我们通篇讲的都是 左闭右闭 区间，理由是这样定义更直接。 细节三：有些学习资料给出了三种模板，例如「力扣」推出的 LeetBook 之 「二分查找专题」，应该如何看待它们？ 回答：我在学习的时候，LeetBook 也是我重要的学习材料之一。三种模板其实区别仅在于退出循环的时候，区间 [left..right] 里有几个数。 while (left while (left while (left + 1 我常用头两个，第一个在简单问题中用，第二个在复杂问题中用。在题解的第 5 部分「5. 两种写法对比」的「重要经验」里也叙述了用它们的理由和场景。 7. 练习 提示：这些问题都不应该当做模板问题来看待，逻辑严密的分析与思考是更关键的。我们针对这些问题都提供了题解，重点分析了应该如何思考，讲解了如何编写正确的代码，希望能够对大家有所帮助。 题型一：二分下标（在数组中查找符合条件的元素的下标） 一般而言这个数组是有序的，也可能是半有序的（旋转有序数组或者山脉数组）。 题目 题解 说明 704. 二分查找（简单） 二分查找的最原始问题，使用本题解介绍的方法就要注意，需要后处理。 34. 在排序数组中查找元素的第一个和最后一个位置（中等） 文字题解 查找边界问题。 33. 搜索旋转排序数组（中等） 文字题解 利用局部单调性，逐步缩小搜索区间（其它问题类似）。 81. 搜索旋转排序数组 II（中等） 文字题解 153. 寻找旋转排序数组中的最小值（中等） 文字题解 154. 寻找旋转排序数组中的最小值 II（中等） 文字题解 300. 最长上升子序列（中等） 文字题解 特别经典的一道「动态规划」，二分查找的思路基于「动态规划」的状态定义得到，代码很像第 35 题。 275. H指数 II（中等） 文字题解 这个问题题目的描述让人迷惑，可以跳过不做。 852. 山脉数组的峰顶索引（简单） 利用局部单调性，逐步缩小搜索区间。 1095. 山脉数组中查找目标值（中等） 文字题解 4. 寻找两个有序数组的中位数（困难） 文字题解 658. 找到 K 个最接近的元素（中等） 文字题解 这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。 题型二：二分答案（在一个有范围的区间里搜索一个整数） 定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。 事实上，二分答案是我们最早接触的二分查找的场景。「幸运 52」里猜价格游戏，就是「二分查找」算法的典型应用：先随便猜一个数，如果猜中，游戏结束。如果猜大了，往小猜；如果猜小了，往大猜。 题目 题解 说明 69. 平方根（简单） 文字题解 在一个整数范围里查找一个整数，也是二分查找法的应用场景。 287. 寻找重复数（中等） 文字题解 在一个整数范围里查找一个整数。这个问题二分查找的解法很反常规（不应该用时间换空间，这么做太傻了），知道即可。 374. 猜数字大小（简单） 文字题解 1300. 转变数组后最接近目标值的数组和 文字题解 题型三：二分答案的升级版：判别条件需要遍历数组 说明：这里给出的问题解法都一样，会一题等于会其它题。问题的场景会告诉我们：目标变量和另一个变量有相关关系（一般是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。 这一类问题可以统称为「 最大值极小化 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题（分割数组的最大值（困难））。 思路是这样的： 分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找； 分析出 单调性，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果； 这一类问题的题目条件一定会给出 连续、正整数 这样的关键字。如果没有，问题场景也一定蕴含了这两个关键信息。 以下给出的问题无一例外。 题目 提示与题解 说明 410. 分割数组的最大值（困难） 文字题解 875. 爱吃香蕉的珂珂（中等） 文字题解 LCP 12. 小张刷题计划（中等） 题解在第 410 题题解里 1482. 制作 m 束花所需的最少天数（中等） 题解在第 1300 题题解里 1552. 两球之间的磁力（中等） 8. 总结 首先想清楚这道问题为什么可以用二分查找解决（而不应该先纠结二分查找该怎么写），利用题目中给出的单调性或者可以缩减问题规模的特点：已知某个猜测的答案的结果，就可以推测出比当前猜测小的时候结果如何，比当前猜测大的时候结果如何。常见应用为：有序或者半有序数组中找下标，确定一个有范围的整数。 首先确定搜索的范围，如果搜索的范围就把正确答案排除在外，那么是无论如何也搜不出正确结果的； 可以从「看到的中间元素什么时候不是解」开始思考 if 的语句怎么写，if 的逻辑越简单越好，这样才能保证不会错，剩下的复杂的情况留给 else，else 的区间就是剩下的区间； 只把区间分成两个部分，代码也写成两个部分，这样，在 while (left 看到 if 和 else 里有 left = mid 的时候，需要将 mid 调整为上取整，原因是当区间里只剩下两个元素的时候，mid 看到右边元素，这样落入 left = mid 的时候，区间才会缩减。如果觉得这一点很难理解的朋友，打印变量看一下就非常清楚了； 如果搜索区间里一定存在目标元素，退出 while (left 不要纠结左闭右闭区间和左闭右开区间。如果你觉得左闭右开区间理解一点问题都没有，当然可以用左闭右开区间定义你的循环不变量。我们通篇介绍的二分查找算法的循环不变量是 [left..right] 里可能存在目标元素，left 包括、right 也包括。 一旦掌握了二分查找算法的思想，用哪种二分查找的写法就是习惯的问题了。模板也是人设计出来的，而且就算是模板，也要有理由。生搬硬套模板是不可以的，一定要明白原理，有一些模板声称是捷径，很有可能是弯路。写算法问题，不可以靠模板。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/374. 猜数字大小.html":{"url":"二分查找/374. 猜数字大小.html","title":"374. 猜数字大小(easy)","keywords":"","body":"题目描述（简单难度） [success] 374. 猜数字大小 解法一：二分法 public class Solution extends GuessGame { public int guessNumber(int n) { int low = 0; int high = n; while(low © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/35. 搜索插入位置.html":{"url":"二分查找/35. 搜索插入位置.html","title":"35. 搜索插入位置(easy)","keywords":"","body":"题目描述（简单难度） [success] 35. 搜索插入位置 解法一：二分法+递归 思路：如果二分法查到到了直接返回，如果没查到，将目标值加入后进行排序，再次二分法查找。 class Solution { public int searchInsert(int[] nums, int target) { int low = 0; int high = nums.length - 1; while (low nums[middle]) { low = middle + 1; } else { high = middle - 1; } } nums = Arrays.copyOf(nums, nums.length + 1); nums[nums.length - 1] = target; Arrays.sort(nums); return searchInsert(nums, target); } } 解法二：优化后的二分法 class Solution { public int searchInsert(int[] nums, int target) { int low = 0; int high = nums.length - 1; int ans = nums.length; while (low © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/278. 第一个错误的版本.html":{"url":"二分查找/278. 第一个错误的版本.html","title":"278. 第一个错误的版本(easy)","keywords":"","body":"题目描述（简单难度） [success] 278. 第一个错误的版本 解法一：二分法 public class Solution extends VersionControl { public int firstBadVersion(int n) { int low = 0; int high = n; int res = -1; while(low 解法二： 暴力 超时 public class Solution extends VersionControl { public int firstBadVersion(int n) { for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/367. 有效的完全平方数.html":{"url":"二分查找/367. 有效的完全平方数.html","title":"367. 有效的完全平方数(easy)","keywords":"","body":"367. 有效的完全平方数(easy) © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/69. x 的平方根.html":{"url":"二分查找/69. x 的平方根.html","title":"69. x 的平方根(easy)","keywords":"","body":"题目描述（简单难度） [success] 69. x 的平方根 解法一：二分法 class Solution { public int mySqrt(int x) { int low = 0; int high = x; int res = -1; while(lowx){ high = middle-1; } else{ low = middle+1; res = middle; } } return res; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/34. 在排序数组中查找元素的第一个和最后一个位置.html":{"url":"二分查找/34. 在排序数组中查找元素的第一个和最后一个位置.html","title":"34. 在排序数组中查找元素的第一个和最后一个位置(easy)","keywords":"","body":"题目描述（中等难度） [warning] 34. 在排序数组中查找元素的第一个和最后一个位置 解法一： 暴力解法 class Solution { public int[] searchRange(int[] nums, int target) { int[] res = new int[2]; boolean flag = true; for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/540. 有序数组中的单一元素.html":{"url":"二分查找/540. 有序数组中的单一元素.html","title":"540. 有序数组中的单一元素(easy)","keywords":"","body":"题目描述（中等难度） [warning] 374. 猜数字大小 解法一： 暴力法 class Solution { public int singleNonDuplicate(int[] nums) { Map map = new HashMap<>(); for(int i=0;i maps : map.entrySet()){ if(maps.getValue() == 1){ return maps.getKey(); } } return -1; } } 优化后的暴力 class Solution { public int singleNonDuplicate(int[] nums) { for(int i=0;i 解法二： 二分法 class Solution { public int singleNonDuplicate(int[] nums) { int low = 0; int high = nums.length-1; while(low © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/275. H 指数 II.html":{"url":"二分查找/275. H 指数 II.html","title":"275. H 指数 II(warning)","keywords":"","body":"题目描述（中等难度） [warning] 275. H 指数 II © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/4. 寻找两个正序数组的中位数.html":{"url":"二分查找/4. 寻找两个正序数组的中位数.html","title":"4. 寻找两个正序数组的中位数(hard)","keywords":"","body":"题目描述（困难难度） [warning] 34. 在排序数组中查找元素的第一个和最后一个位置 解法一：暴力 合并数组后排序，再通过二分得出中位数，不符合时间复杂度要求。 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int begin = nums1.length; nums1 = Arrays.copyOf(nums1, nums1.length + nums2.length); System.arraycopy(nums2,0,nums1,begin,nums2.length); Arrays.sort(nums1); int l = 0; int r = nums1.length-1; int middle = l + (r-l)/2; if(nums1.length %2 == 0){ return (nums1[middle]+nums1[middle+1])/2.0; } else{ return nums1[middle]/1.0; } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"二分查找/153. 寻找旋转排序数组中的最小值.html":{"url":"二分查找/153. 寻找旋转排序数组中的最小值.html","title":"153. 寻找旋转排序数组中的最小值(medium)","keywords":"","body":"题目描述（中等难度） [warning] 153. 寻找旋转排序数组中的最小值 解法一： 暴力 class Solution { public int findMin(int[] nums) { if(nums.length == 0 || null == nums){ return -1; } Arrays.sort(nums); return nums[0]; } } 暴力求最小值 class Solution { public int findMin(int[] nums) { Integer min = Integer.MAX_VALUE; for(int i=0;i 以上方式时间复杂度太差，不推荐 解法二： 二分法 class Solution { public int findMin(int[] nums) { int l = 0; int r = nums.length-1; while(l nums[nums.length-1]){ l = middle+1; } else{ r = middle; } } return nums[l]; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/动态规划.html":{"url":"简介/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"动态规划/509. 斐波那契数.html":{"url":"动态规划/509. 斐波那契数.html","title":"509. 斐波那契数(easy)","keywords":"","body":"题目描述（简单难度） [success] 509. 斐波那契数 解法一：暴力递归 class Solution { public int fib(int n) { if(n == 0 || n==1){ return n; } return fib(n-1)+fib(n-2); } } 解法二：备忘录递归 class Solution { int[] cache = new int[101]; public int fib(int n) { if(n == 0 || n==1){ return n; } if(cache[n] != 0){ return cache[n]; } cache[n] = fib(n-1)+fib(n-2); return cache[n]; } } 解法三：动态规划 class Solution { public int fib(int n) { if(n == 0){ return 0; } int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; for(int i=2;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"动态规划/5. 最长回文子串.html":{"url":"动态规划/5. 最长回文子串.html","title":"5. 最长回文子串(中等)","keywords":"","body":"5. 最长回文子串(中等) © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"动态规划/746. 使用最小花费爬楼梯.html":{"url":"动态规划/746. 使用最小花费爬楼梯.html","title":"746. 使用最小花费爬楼梯(easy)","keywords":"","body":"题目描述（简单难度） [success] 746. 使用最小花费爬楼梯 解法一：动态规划 class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for(int i=2;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"动态规划/63. 不同路径 II.html":{"url":"动态规划/63. 不同路径 II.html","title":"63. 不同路径 II(中等)","keywords":"","body":"题目描述（中等难度） [success] 63. 不同路径 II 解法一：动态规划 class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(null == obstacleGrid || obstacleGrid.length == 0){ return 0; } int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; dp[0][0] = 1 - obstacleGrid[0][0]; //base case for(int i=1;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"动态规划/343. 整数拆分.html":{"url":"动态规划/343. 整数拆分.html","title":"343. 整数拆分(中等)","keywords":"","body":"343. 整数拆分(中等) © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"动态规划/300. 最长递增子序列.html":{"url":"动态规划/300. 最长递增子序列.html","title":"300. 最长递增子序列(中等)","keywords":"","body":"题目描述（中等难度） [success] 300. 最长递增子序列 解法一：动态规划 状态转义方程：dp[i] = max(dp[i], dp[j] + 1) class Solution { public int lengthOfLIS(int[] nums) { if(null == nums || nums.length == 0){ return 0; } int[] dp = new int[nums.length]; for(int i=0;i nums[j]){ dp[i] = Math.max(dp[i],dp[j]+1); } } res = Math.max(res,dp[i]); } return res; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/高频TOP200.html":{"url":"简介/高频TOP200.html","title":"NC算法","keywords":"","body":"NC算法 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"NC/NC78.反转链表.html":{"url":"NC/NC78.反转链表.html","title":"NC78.反转链表","keywords":"","body":"NC78.反转链表 题目描述 输入一个链表，反转链表后，输出新链表的表头。 示例1 输入 {1,2,3} 返回值 {3,2,1} 解法一：常规解法 public class Solution { public ListNode ReverseList(ListNode head) { ListNode prev = null; ListNode curr = head; ListNode temp = null; while(curr != null){ temp = curr.next; curr.next = prev; prev = curr; curr = temp; } return prev; } } 解法二 ： 栈 解题思路：因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下 import java.util.*; public class Solution { public ListNode ReverseList(ListNode head) { Deque deque = new LinkedList<>(); while(head != null){ deque.offer(head); head = head.next; } if(deque.isEmpty()){ return null; } ListNode node = deque.pollLast(); ListNode dummy = node; while(!deque.isEmpty()){ ListNode temp = deque.pollLast(); node.next = temp; node = node.next; } node.next = null; return dummy; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"NC/NC140.排序.html":{"url":"NC/NC140.排序.html","title":"NC140.排序","keywords":"","body":"NC140.排序 题目描述 给定一个数组，请你编写一个函数，返回该数组排序后的形式。 示例1 输入 [5,2,3,1,4] 返回值 [1,2,3,4,5] 示例2 输入 [5,1,6,2,5] 返回值 [1,2,5,5,6] 备注: 数组的长度不大于100000，数组中每个数的绝对值不超过10^9109 解法一：冒泡排序 时间复杂度O(n^2) public class Solution { public int[] MySort (int[] arr) { for(int i=0;iarr[j]){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } return arr; } } 解法二：快速排序 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"NC/NC50.K 个一组翻转链表.html":{"url":"NC/NC50.K 个一组翻转链表.html","title":"NC50.K 个一组翻转链表","keywords":"","body":"NC50.K 个一组翻转链表 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/子序列问题.html":{"url":"简介/子序列问题.html","title":"子序列问题","keywords":"","body":"子序列问题 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"子序列问题/1143. 最长公共子序列.html":{"url":"子序列问题/1143. 最长公共子序列.html","title":"1143. 最长公共子序列","keywords":"","body":"题目描述（中等难度） [warning] 1143. 最长公共子序列 解法一：暴力法，求出字符串所有子序列，再取出最大的，超时 class Solution { Set aMap = new HashSet<>(); Set bMap = new HashSet<>(); public int longestCommonSubsequence(String text1, String text2) { if(text1 != null || text1.length() != 0){ subStr(text1.toCharArray(),0,\"\",aMap); } if(text2 != null || text2.length() != 0){ subStr(text2.toCharArray(),0,\"\",bMap); } int max = 0; for(String s : aMap){ if(bMap.contains(s)){ max = Math.max(max,s.length()); } } return max; } //递归求所有子序列 public void subStr(char[] str,int index,String res,Set set){ if(index == str.length){ set.add(res); return; } subStr(str,index+1,res,set); subStr(str,index+1,res+String.valueOf(str[index]),set); } } 解法二：动态规划 class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(); int n = text2.length(); int[][] dp = new int[m+1][n+1]; for(int i=1;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/剑指offer.html":{"url":"简介/剑指offer.html","title":"剑指offer","keywords":"","body":"剑指offer © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 04. 二维数组中的查找.html":{"url":"剑指offer/剑指 Offer 04. 二维数组中的查找.html","title":"剑指 Offer 04. 二维数组中的查找","keywords":"","body":"题目描述（中等难度） [warning] 剑指 Offer 04. 二维数组中的查找 解法一：暴力，两个for循环，或者一个循环一个二分 class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { for(int i=0;i target){ high = middle-1; } else{ low = middle+1; } } } return false; } } 解法二： 线性查找 二分法 解题思路 由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。 从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。 可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。 若数组为空，返回 false 初始化行下标为 0，列下标为二维数组的列数减 1 重复下列步骤，直到行下标或列下标超出边界 获得当前下标位置的元素 num 如果 num 和 target 相等，返回 true 如果 num 大于 target，列下标减 1 如果 num 小于 target，行下标加 1 循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false` class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if(matrix == null || matrix.length == 0){ return false; } int rows = matrix.length; int columns = matrix[0].length; int row = 0; int col = columns-1; while(row =0){ if(matrix[row][col] == target){ return true; } if(matrix[row][col] > target){ col--; } else{ row++; } } return false; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 05. 替换空格.html":{"url":"剑指offer/剑指 Offer 05. 替换空格.html","title":"剑指 Offer 05. 替换空格","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 05. 替换空格 解法一：遍历替换 class Solution { public String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); for(int i=0;i 解法二：使用库函数 class Solution { public String replaceSpace(String s) { return s.replace(\" \",\"%20\"); } } 解法三：字符数组方式 class Solution { public String replaceSpace(String s) { char[] array = new char[s.length()*3]; int size = 0; for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 06. 从尾到头打印链表.html":{"url":"剑指offer/剑指 Offer 06. 从尾到头打印链表.html","title":"剑指 Offer 06. 从尾到头打印链表","keywords":"","body":"题目描述（简单难度） [success] 剑指 Offer 06. 从尾到头打印链表 解法一：先反转链表再输出 class Solution { public int[] reversePrint(ListNode head) { if(head == null){ return new int[0]; } List list = new ArrayList<>(); ListNode prev = null; ListNode curr = head; ListNode temp = null; while(curr != null){ temp = curr.next; curr.next = prev; prev = curr; curr = temp; } while(prev != null){ list.add(prev.val); prev = prev.next; } int[] result = new int[list.size()]; for(int i=0;i 解法二： 从数组最后一位开始输入 class Solution { public int[] reversePrint(ListNode head) { if(null == head){ return new int[0]; } ListNode node = head; int size = 0; while(node != null){ node = node.next; size++; } int[] res = new int[size]; node = head; for(int i=size-1;i>=0;i--){ res[i] = node.val; node = node.next; } return res; } } 解法三： 栈 class Solution { public int[] reversePrint(ListNode head) { Deque deque = new ArrayDeque<>(); ListNode curr = head; while(curr != null){ deque.offerLast(curr.val); curr = curr.next; } int size = deque.size(); int[] res = new int[size]; for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 07. 重建二叉树.html":{"url":"剑指offer/剑指 Offer 07. 重建二叉树.html","title":"剑指 Offer 07. 重建二叉树","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 07. 重建二叉树 解法一： class Solution { Map map = new HashMap<>(); public TreeNode buildTree(int[] preorder, int[] inorder) { if(preorder.length != inorder.length){ return null; } int n = preorder.length; for(int i=0;i map,int inLeft,int inRight){ if(preLeft > preRight || inLeft > inRight){ return null; } int rootVal = preorder[preLeft]; int preIndex = map.get(rootVal); TreeNode root = new TreeNode(rootVal); root.left = buildTree(preorder,preLeft+1,preIndex-inLeft + preLeft,map,inLeft,preIndex-1); root.right = buildTree(preorder,preIndex-inLeft + preLeft+1,preRight,map,preIndex+1,inRight); return root; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 09. 用两个栈实现队列.html":{"url":"剑指offer/剑指 Offer 09. 用两个栈实现队列.html","title":"剑指 Offer 09. 用两个栈实现队列","keywords":"","body":"题目描述（中等难度） [success] [剑指 Offer 09. 用两个栈实现队列 解法一： 两个栈实现 class CQueue { Deque A; Deque B; public CQueue() { A= new LinkedList<>(); B= new LinkedList<>(); } public void appendTail(int value) { A.offerFirst(value); } public int deleteHead() { if(B.isEmpty()){ while(!A.isEmpty()){ B.offerFirst(A.pollFirst()); } } if(B.isEmpty()){ return -1; } return B.pollFirst(); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 22. 链表中倒数第k个节点.html":{"url":"剑指offer/剑指 Offer 22. 链表中倒数第k个节点.html","title":"剑指 Offer 22. 链表中倒数第k个节点","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 22. 链表中倒数第k个节点 解法一：遍历链表 遍历链表，统计链表长度n，倒数第k个就是正数第n-k个 class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if(head == null){ return null; } int n = 0; ListNode curr = head; while(curr != null){ n++; curr = curr.next; } ListNode temp = head; int index = 0; while(temp != null){ if(index == n-k){ return temp; } temp = temp.next; index++; } return null; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 33. 二叉搜索树的后序遍历序列.html":{"url":"剑指offer/剑指 Offer 33. 二叉搜索树的后序遍历序列.html","title":"剑指 Offer 33. 二叉搜索树的后序遍历序列","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 33. 二叉搜索树的后序遍历序列 解法一：递归分治 划分左右子树： 遍历后序遍历的 [i,j] 区间元素，寻找 第一个大于根节点 的节点，索引记为 m 。此时，可划分出左子树区间 [i,m−1] 、右子树区间 [m, j - 1] 、根节点索引 j 。 class Solution { public boolean verifyPostorder(int[] postorder) { if(postorder.length =right){ return true; } //当前树的根节点的值 int root = postorder[right]; int m = left; //当前区域第一个大于根节点的，说明后续区域的值都是右子树的节点 for(int i=left;i 解法二：单调栈 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 37. 序列化二叉树.html":{"url":"剑指offer/剑指 Offer 37. 序列化二叉树.html","title":"剑指 Offer 37. 序列化二叉树","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 37. 序列化二叉树 解法一： © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 60. n个骰子的点数.html":{"url":"剑指offer/剑指 Offer 60. n个骰子的点数.html","title":"剑指 Offer 60. n个骰子的点数","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 60. n个骰子的点数 解法一： © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 30. 包含min函数的栈.html":{"url":"剑指offer/剑指 Offer 30. 包含min函数的栈.html","title":"剑指 Offer 30. 包含min函数的栈","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 30. 包含min函数的栈 解法一：优先队列与栈实现 class MinStack { PriorityQueue priority; Deque queue; /** initialize your data structure here. */ public MinStack() { queue = new LinkedList(); priority = new PriorityQueue(); } public void push(int x) { queue.offerFirst(x); priority.offer(x); } public void pop() { if(!queue.isEmpty()){ priority.remove(queue.peekFirst()); queue.pollFirst(); } } public int top() { if(!queue.isEmpty()){ return queue.peekFirst(); } return -1; } public int min() { if(!priority.isEmpty()){ return priority.peek(); } return -1; } } 解法二：使用辅助栈实现 class MinStack { Deque A; Deque B; public MinStack() { A = new LinkedList<>(); B = new LinkedList<>(); } public void push(int x) { A.offerFirst(x); if(B.isEmpty() || B.peekFirst() >= x){ B.offerFirst(x); } else{ B.offerFirst(B.peekFirst()); } } public void pop() { if(!A.isEmpty()){ A.pollFirst(); B.pollFirst(); } } public int top() { if(!A.isEmpty()){ return A.peekFirst(); } return -1; } public int min() { if(!B.isEmpty()){ return B.peekFirst(); } return -1; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 38. 字符串的排列.html":{"url":"剑指offer/剑指 Offer 38. 字符串的排列.html","title":"剑指 Offer 38. 字符串的排列","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 38. 字符串的排列 解法一： 回溯 注意题目，字符串可以有重复字符，如果字符串没有重复字符，就不需要做去重校验了，有重复字符，使用一个boolean 数组做去重校验。 class Solution { Set set = new HashSet<>(); StringBuilder sb = new StringBuilder(); public String[] permutation(String s) { if(s.length() == 0 || null == s){ return new String[0]; } boolean[] used = new boolean[s.length()]; backtrack(s,used); return set.toArray(new String[]{}); } public void backtrack(String s,boolean[] used){ if(sb.length() == s.length()){ set.add(sb.toString()); return; } for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 44. 数字序列中某一位的数字.html":{"url":"剑指offer/剑指 Offer 44. 数字序列中某一位的数字.html","title":"剑指 Offer 44. 数字序列中某一位的数字","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 44. 数字序列中某一位的数字 解法一：暴力 超出内存限制 class Solution { public int findNthDigit(int n) { StringBuilder sb = new StringBuilder(); for(int i=0;i 解法二：二分法 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 46. 把数字翻译成字符串.html":{"url":"剑指offer/剑指 Offer 46. 把数字翻译成字符串.html","title":"剑指 Offer 46. 把数字翻译成字符串","keywords":"","body":"剑指 Offer 46. 把数字翻译成字符串 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 47. 礼物的最大价值.html":{"url":"剑指offer/剑指 Offer 47. 礼物的最大价值.html","title":"剑指 Offer 47. 礼物的最大价值","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 47. 礼物的最大价值 解法一：动态规划 class Solution { public int maxValue(int[][] grid) { if(grid == null || grid.length == 0){ return 0; } int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; //base case dp[0][0] = grid[0][0]; for(int i=1;i 简化代码 ，动态规划 class Solution { public int maxValue(int[][] grid) { if(grid == null || grid.length == 0){ return 0; } int m = grid.length; int n = grid[0].length; int[][] dp = new int[m+1][n+1]; for(int i=1;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 48. 最长不含重复字符的子字符串.html":{"url":"剑指offer/剑指 Offer 48. 最长不含重复字符的子字符串.html","title":"剑指 Offer 48. 最长不含重复字符的子字符串","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 48. 最长不含重复字符的子字符串 解法一：滑动窗口 class Solution { public int lengthOfLongestSubstring(String s) { if(s.length() == 0 || s == null){ return 0; } if(s.length() == 1){ return 1; } int l = 0; int r = l+1; int max = Integer.MIN_VALUE; Set set = new HashSet<>(); while(l(); l++; r = l+1; } max = Math.max(max,set.size()); } return max; } } 滑动窗口 优化 class Solution { public int lengthOfLongestSubstring(String s) { if(s.length() == 0 || s == null){ return 0; } int l = 0; int r = 0 ; int max = 0; int n = s.length(); Set set = new HashSet<>(); while(l © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 49. 丑数.html":{"url":"剑指offer/剑指 Offer 49. 丑数.html","title":"剑指 Offer 49. 丑数","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 49. 丑数 解法一：暴力 超时 class Solution { public int nthUglyNumber(int n) { List list = new ArrayList<>(); for(int i=1;i0){ for(int i=2;i 解法二： 优先队列 最小堆 class Solution { public int nthUglyNumber(int n) { int[] ans = {2,3,5}; Set set = new HashSet<>(); PriorityQueue priority = new PriorityQueue(); priority.offer(1L); set.add(1L); int ugly = 0; for(int i=0;i 解法三：动态规划 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 57 - II. 和为s的连续正数序列.html":{"url":"剑指offer/剑指 Offer 57 - II. 和为s的连续正数序列.html","title":"剑指 Offer 57 - II. 和为s的连续正数序列","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 57 - II. 和为s的连续正数序列 解法一： 暴力 class Solution { public int[][] findContinuousSequence(int target) { List> ans = new ArrayList<>(); for(int i=1;i list = new ArrayList<>(); list.add(i); int sum = i; for(int j=i+1;j target){ break; } } } int[][] resp = new int[ans.size()][]; for(int i=0;i 解法二：双指针 滑动窗口 class Solution { public int[][] findContinuousSequence(int target) { List> ans = new ArrayList<>(); for(int l=1,r=2;l list = new ArrayList<>(); int sum = ((l+r)*(r-l+1))/2; if(sum == target){ for(int i=l;i target){ l++; } else{ r++; } } int[][] resp = new int[ans.size()][]; for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 59 - I. 滑动窗口的最大值.html":{"url":"剑指offer/剑指 Offer 59 - I. 滑动窗口的最大值.html","title":"剑指 Offer 59 - I. 滑动窗口的最大值","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 59 - I. 滑动窗口的最大值 解法一：双指针滑动窗口 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(nums.length == 0 || nums == null){ return new int[0]; } int i = 0; int j = k-1; int n = nums.length-1; List ans = new ArrayList<>(); while(j 解法二：优先队列 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 59 - II. 队列的最大值.html":{"url":"剑指offer/剑指 Offer 59 - II. 队列的最大值.html","title":"剑指 Offer 59 - II. 队列的最大值","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 59 - II. 队列的最大值 解法一：队列实现 class MaxQueue { Deque queue; Deque queue1; public MaxQueue() { queue = new LinkedList<>(); queue1 = new LinkedList<>(); } public int max_value() { if(queue1.isEmpty()){ return -1; } return queue1.peekFirst(); } public void push_back(int value) { queue.offerLast(value); while(!queue1.isEmpty() && queue1.peekLast() © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 61. 扑克牌中的顺子.html":{"url":"剑指offer/剑指 Offer 61. 扑克牌中的顺子.html","title":"剑指 Offer 61. 扑克牌中的顺子","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 61. 扑克牌中的顺子 解法一：集合set + 遍历 class Solution { public boolean isStraight(int[] nums) { Set set = new HashSet<>(); int min = 14; int max = 0; for(int i=0;i 解法二： 排序+ 遍历 class Solution { public boolean isStraight(int[] nums) { Arrays.sort(nums); int index = 0; for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 62. 圆圈中最后剩下的数字.html":{"url":"剑指offer/剑指 Offer 62. 圆圈中最后剩下的数字.html","title":"剑指 Offer 62. 圆圈中最后剩下的数字","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 62. 圆圈中最后剩下的数字 解法一：模拟 class Solution { public int lastRemaining(int n, int m) { List ans = new ArrayList<>(); for(int i=0;i 1){ idx = (idx+m-1) % n; ans.remove(idx); n--; } return ans.get(0); } } 解法二： 数学法 class Solution { public int lastRemaining(int n, int m) { int ans = 0; // 最后一轮剩下2个人，所以从2开始反推 for (int i = 2; i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 63. 股票的最大利润.html":{"url":"剑指offer/剑指 Offer 63. 股票的最大利润.html","title":"剑指 Offer 63. 股票的最大利润","keywords":"","body":"题目描述（中等难度） [success] 剑指 Offer 63. 股票的最大利润 解法一：暴力 class Solution { public int maxProfit(int[] prices) { if(prices == null || prices.length == 0){ return 0; } int max = Integer.MIN_VALUE; for(int i=0;i 解法二：动态规划 class Solution { public int maxProfit(int[] prices) { if(prices == null || prices.length == 0){ return 0; } int n = prices.length; int[] dp = new int[n]; dp[0] =0; //最小入手价 int cost = prices[0]; for(int i=1;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 65. 不用加减乘除做加法.html":{"url":"剑指offer/剑指 Offer 65. 不用加减乘除做加法.html","title":"剑指 Offer 65. 不用加减乘除做加法","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 65. 不用加减乘除做加法 解法一：位运算 class Solution { public int add(int a, int b) { while(b != 0){ int c = (a&b) © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 67. 把字符串转换成整数.html":{"url":"剑指offer/剑指 Offer 67. 把字符串转换成整数.html","title":"剑指 Offer 67. 把字符串转换成整数","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 67. 把字符串转换成整数 解法一：字符串处理 class Solution { public int strToInt(String str) { str = str.trim(); if(str.length() == 0){ return 0; } int sign = 1; int i = 1; if(str.charAt(0)=='-'){ sign = -1; }else if(str.charAt(0) != '+'){ i = 0; } int number = Integer.MAX_VALUE /10; int res = 0; for(int j=i;j '9' || str.charAt(j) number || (res==number && str.charAt(j) > '7')){ return sign == 1?Integer.MAX_VALUE : Integer.MIN_VALUE; } res = res * 10 + (str.charAt(j) - '0'); } return res*sign; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 66. 构建乘积数组.html":{"url":"剑指offer/剑指 Offer 66. 构建乘积数组.html","title":"剑指 Offer 66. 构建乘积数组","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 66. 构建乘积数组 解法一：动态规划 如果我们能计算每个元素左边所有元素的乘积和右边所有元素的乘积 只需要把他们相乘就可以满足这题的要求 左边的从左边开始 右边的从右边开始 class Solution { public int[] constructArr(int[] a) { if(a == null || a.length == 0){ return new int[0]; } int length = a.length; int[] leftDp = new int[length]; int[] rightDp = new int[length]; leftDp[0] = 1; for(int i=1;i=0;j--){ rightDp[j] = rightDp[j+1]*a[j+1]; } int[] resp = new int[length]; for(int i=0;i © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 68 - I. 二叉搜索树的最近公共祖先.html":{"url":"剑指offer/剑指 Offer 68 - I. 二叉搜索树的最近公共祖先.html","title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 解法一： 递归 利用二叉树的特性，如果p 、q 的值小于root ,p q就在root的左边、如果 p、q 的值大于root 就在root的右边 否则在他们的公共祖先就是root class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null){ return null; } if(root.val > p.val && root.val > q.val){ return lowestCommonAncestor(root.left,p,q); } else if(root.val 解法二： 迭代法 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null){ return root; } while(root != null){ if(root.val > p.val && root.val > q.val){ root = root.left; } else if(root.val © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"剑指offer/剑指 Offer 68 - II. 二叉树的最近公共祖先.html":{"url":"剑指offer/剑指 Offer 68 - II. 二叉树的最近公共祖先.html","title":"剑指 Offer 68 - II. 二叉树的最近公共祖先","keywords":"","body":"题目描述（简单难度） [warning] 剑指 Offer 68 - II. 二叉树的最近公共祖先 解法一： 递归 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null){ return null; } if(root == p || root == q){ return root; } TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left != null && right != null){ return root; } if(left != null){ return left; } if(right != null){ return right; } return null; } } 简化上面答案 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null){ return null; } if(root == p || root == q){ return root; } TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null){ return right; } if(right == null){ return left; } return root; } } 解法二： hashMap保存父节点 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { HashMap map = new HashMap<>(); Set set = new HashSet<>(); public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root); while(p != null){ set.add(p.val); p = map.get(p.val); } while(q !=null){ if(set.contains(q.val)){ return q; } q = map.get(q.val); } return null; } public void dfs(TreeNode root){ if(root == null){ return; } if(root.left != null){ map.put(root.left.val,root); dfs(root.left); } if(root.right != null){ map.put(root.right.val,root); dfs(root.right); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/排序算法.html":{"url":"简介/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 归并排序 class Solution{ public static void main(String[] args) { int[] nums1 = {1,3,2,5,9,0}; merge(nums1,0,nums1.length-1); System.out.println(Arrays.toString(nums1)); } public static void merge(int[] nums,int low,int high){ int middle = low + (high-low)/2; if(low © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"排序/NC78.反转链表.html":{"url":"排序/NC78.反转链表.html","title":"NC78.反转链表","keywords":"","body":"NC78.反转链表 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/位运算.html":{"url":"简介/位运算.html","title":"位运算","keywords":"","body":"位运算 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"位运算/剑指 Offer 56 - I. 数组中数字出现的次数.html":{"url":"位运算/剑指 Offer 56 - I. 数组中数字出现的次数.html","title":"剑指 Offer 56 - I. 数组中数字出现的次数","keywords":"","body":"剑指 Offer 56 - I. 数组中数字出现的次数 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/后端存储.html":{"url":"简介/后端存储.html","title":"后端存储","keywords":"","body":"后端存储 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/MySQL.html":{"url":"简介/MySQL.html","title":"MySQL","keywords":"","body":"MySQL Mysql基础架构 MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎 连接器:连接器负责跟客户端建立连接、获取权限、维持和管理连接 查询缓存：拿到请求后，先到查询缓存中看是否有数据，不建议使用查询缓存，失效频率非常高，一个更新操作就会使查询缓存都失效。 分析器：词法分析、语法分析、判断sql语句是否正确。 优化器: 存在多个索引时，决定使用哪个索引 ，join连接顺序。 执行器： 执行语句，判断是否有权限查询。 Mysql 日志系统 重要的日志模块：redo log Mysql WAL(Write-Ahead Logging) 技术，它的关键点就是先写日志，再写磁盘，当更新一条记录的时候，innodb会先把记录写到redo log里，等系统比较空闲的时候再把数据写入磁盘。 重要的日志模块：binlog binlog 是mysql service 层层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以\"事务\"的形式保存在磁盘中； binlog记录的是执行的sql语句 binlog 与redo log区别 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 事务隔离 提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。 事务的隔离级别 1、读未提交（READ-UNCOMMITTED）：也就是允许读到未提交的内容，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。 2、读已提交（READ-COMMITTED）：读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于RDBMS中常见的默认隔离级别（比如说Oracle和SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在SQL查询的时候编写带加锁的SQL语句。 3、可重复读（REPEATABLE-READ），保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL默认的隔离级别就是可重复读。 4、可串行化（SERIALIZABLE），将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。 事务的隔离级别，每个级别是如何解决的。 MySQL 事务隔离其实是依靠锁来实现的.而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决. 读提交隔离级别可以解决脏读问题：但会存在幻读与不可重复读问题 在同一事务中(本例中的事务B)，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别。 读未提交：不加任何锁 串行化：读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。 可重复读：为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。 幻读：解决幻读使用的是间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。 读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。 数据库索引 InnoDB 的索引模型：在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。 基于主键索引和普通索引的查询有什么区别？ 主键索引也就是是聚簇索引，叶子节点存储了数据的行，根据主键查询，直接搜索 ID 这棵 B+ 树就拿到了数据。 普通索引查询方式，则需要先搜索索引树，得到 主键的值，再到主键索引树搜索一次。这个过程称为回表。 避免回表查询的方法：覆盖索引 最左前缀原则：最左前缀可以用于在索引中定位记录 建索引的几大原则：1、最左前缀匹配原则、mysql一直向右匹配，直到遇到范围查询就停止匹配。2、=和in可以乱序 3、尽量选择区分度高的列作为索引 慢查询优化基本步骤 先运行看看是否真的很慢，注意设置SQL_NO_CACHE where条件单表查，锁定最小返回记录表 explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询） order by limit 形式的sql语句让排序的表优先查 了解业务方使用场景 加索引时参照建索引的几大原则 观察结果，不符合预期继续从0分析 Mysql锁 Mysql锁可以分为 全局锁、表级锁和行锁三类 全局锁：锁的是整个数据库实例，这个库处于只读状态，任何更新删除修改、数据定义语句都会被阻塞。全局锁的使用场景主要是：做全库逻辑备份。 表级锁：表锁的语法是 lock tables … read/write，使用unlock tables 主动释放锁。 行锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。 Mysql普通索引与唯一索引 普通索引，查到满足条件的第一个记录后，继续查找下一个记录，直到第一个不满足条件的记录 唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索 但是，两者的性能差距微乎其微。因为InnoDB根据数据页来读写的。 概念： change buffer 当需要更新一个数据页，如果数据页在内存中就直接更新，如果不在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中。下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中的与这个页有关的操作。 唯一索引的更新不能使用change buffer，change buffer使用场景：写多读少场景，适用于写入后不立马做查询的业务场景 字符串字段创建索引的场景： 直接创建完整索引，这样可能比较占用空间 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。 SQL语句性能分析 t_modified 字段有索引，以下查询是否用到了索引，答案：没有使用索引。 select count(*) from tradelog where month(t_modified)=7; 如果对字段做了函数计算，就用不上索引了，这是 MySQL 的规定。对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。 函数计算不走索引 为什么有数据类型转换，就需要走全索引扫描。 隐式字符编码转换不走索引 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"MySQL/数据库事务.html":{"url":"MySQL/数据库事务.html","title":"数据库事务","keywords":"","body":"简介 数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 事务的特性：ACID A，也就是原子性（Atomicity）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。 C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。 I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。 D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。 数据库隔离级别 事务并发可能存在的异常有哪些？ 1、脏读: 读到了其他事务还没有提交的数据。 例子：A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。 2、丢失修改（Lost to modify）指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 3、不可重复读：前后多次读取，数据内容不一致 例子：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。 4：幻读：前后多次读取，数据总量不一致 事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。 不可重复度和幻读区别： 不可重复读针对的是修改操作，幻读针对的于新增或者删除操作。 事务的四种隔离级别 1、读未提交（READ-UNCOMMITTED）：也就是允许读到未提交的内容，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。 2、读已提交（READ-COMMITTED）：读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于RDBMS中常见的默认隔离级别（比如说Oracle和SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在SQL查询的时候编写带加锁的SQL语句。 3、可重复读（REPEATABLE-READ），保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL默认的隔离级别就是可重复读。 4、可串行化（SERIALIZABLE），将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。 事物隔离的实现 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。 事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC） 事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。 常见数据库事物面试题 介绍一下数据库的事务 Mysql 有哪些隔离级别 Mysql 什么情况会造成脏读、可重复读、幻读？如何解决。 Mysql 在可重复读的隔离级别下会不会有幻读的情况，为什么？ Mysql 事务是如何实现的。 数据库MVCC © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"MySQL/数据库索引.html":{"url":"MySQL/数据库索引.html","title":"数据库索引","keywords":"","body":"数据库索引 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/Redis.html":{"url":"简介/Redis.html","title":"Redis","keywords":"","body":"Redis Redis底层数据结构与实现 Redis底层数据结构一共有六种，分别是动态字符串、双向链表、压缩列表、哈希表、跳表和整形列表。 为了实现从键到值的快速访问，Redis的键和值使用一个哈希表来保存,哈希桶中的entry元素中保存了key和value指针，分别指向了实际的键和值。 潜在的风险点 为什么哈希表操作变慢了？ 原因：哈希表的冲突问题和rehash操作可能带来的操作阻塞。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/底层数据结构与实现.html":{"url":"Redis/底层数据结构与实现.html","title":"1、Redis底层数据结构与实现","keywords":"","body":"Redis底层数据结构与实现 Redis底层数据结构一共有六种，分别是动态字符串、双向链表、压缩列表、哈希表、跳表和整形列表。 为了实现从键到值的快速访问，Redis的键和值使用一个哈希表来保存,哈希桶中的entry元素中保存了key和value指针，分别指向了实际的键和值。 潜在的风险点 为什么哈希表操作变慢了？ 原因：哈希表的冲突问题和rehash操作可能带来的操作阻塞。 Redis解决哈希冲突方式：链式哈希，存在的问题，哈希表数据越来越多，哈希冲突越来越多，链表长度过长，查询耗时过长，查询效率变低。 解决办法：Redis对哈希表做rehash操作，rehash也就是增加现在的哈希桶数量，分散元素，减少冲突，减少链表长度。 原始方法：默认保存数据到哈希表1，给哈希表2分配更大的空间，将哈希表1的数据重新映射拷贝到哈希表2，释放哈希表1的空间，会存在的问题：大量的数据拷贝，造成redis线程阻塞。 渐进式哈希 第二步拷贝数据时，Redis仍正常处理客户端请求，每处理一个请求，从哈希表1中第一个索引的位置开始，将entry拷贝到哈希表2中，下次请求再把索引为2的数据拷贝过去，直到全部拷贝完毕，索引置为-1结束，分摊耗时。 集合数据的操作效率 查找一个集合类型的值，第一步通过全局哈希表找到哈希桶的位置，第二步在集合中再进行增删改查。 整数数组(O(n))、双向链表(O(n))、哈希表O(1)都比较常见，压缩列表(O(n))和跳表(O(logN))不常见。 压缩列表 跳表 跳表相当于链表的二分法，通过增加多级索引的方式，通过索引位置的跳转实现数据的快速定位。 不同操作的复杂度，单元素操作指每一种集合类型对单个数据实现增删改查操作，比如Hash类型的HGET、HSET、HDEL，范围操作、比如HGETALL、LRANGE、ZRANGE等，应当尽量避免全量查询语句操作，存在Reids阻塞风险。 如果集合类型采用整数数组、压缩列表、双向链表保存数据，统计元素个数的时间复杂度为O(1)。建议使用SCAN命令 压缩列表和双向链表会记录头尾的偏移量，LPOP、RPOP、LPUSH、RPUSH等操作时间复杂度为O(1); 总结 1、整数数组和压缩列表在查找时间复杂度方面没有太大优势，为什么Redis还把他们当作底层数据结构呢。 答：Redis之所以使用不同的数据结构，其实是在性能与内存使用效率之间进行平衡。 整数据数组和压缩列表都是在内存中分配一块连续的内存空间，不需要额外的指针将数据串接起来，避免指针带来的额外空间消耗，内存布局非常节省空间。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/Redis高性能IO模型.html":{"url":"Redis/Redis高性能IO模型.html","title":"2、Redis高性能IO模型","keywords":"","body":"Redis高性能IO模型 Redis为什么用单线程，Redis为什么那么快？ 使用单线程原因：多线程开销大，涉及到上下文切换，为保证共享资源的正确性，需要额外的锁机制进行保障，带来了额外的开销，这就是多线程编程面临的共享资源并发访问控制问题，为了避免这些问题，Redis直接采用单线程模式。 Redis快的原因： 单线程，避免了多线程的上下文切换开锁，共享资源并发控制开销 Redis大部分操作在内存中完成的 高效的数据结构，使用一个全局哈希表，底层数据结构高效，如使用哈希表和跳表。 多路复用机制的IO模型 基于多路复用的高性能I/O模型 什么是IO多路复用 I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作 Linux中的IO多路复用机制是指一个线程处理多个IO流，就是我们经常听到的select/epoll机制,简单来说，就是Redis只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听 这些套接字上的连接请求，或数据请求，一旦有请求到达，就会交给Redis线程处理，就实现了一个Redis线程处理多个IO流的效果。 基于Redis多路复用的IO模型 select/epoll提供基于事件的回调机制，事件放在事件队列里，Redis单线程不断处理事件队列，避免轮询浪费CPU资源。 小结 Redis单线程是指它对网络IO和数据读写的操作采用一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。单线程的Redis高性能的原因跟多路复用的IO模型密切相关，因为这避免了accept()和send()/recv()潜在的网络阻塞操作。 总结 1、在Redis基本IO模型中，你觉得还潜在哪些性能瓶颈。 主要是阻塞操作对Redis单线程的性能影响，比如主线程在执行操作，任何耗时的操作，比如bigKey，全量返回等操作(引入的scan操作可以避免)，都是潜在性能瓶颈。 2、Redis为什么是单线程的，Redis为什么这么快。 使用单线程原因：多线程开销大，涉及到上下文切换，为保证共享资源的正确性，需要额外的锁机制进行保障，带来了额外的开销，这就是多线程编程面临的共享资源并发访问控制问题，为了避免这些问题，Redis直接采用单线程模式。 Redis快的原因： 单线程，避免了多线程的上下文切换开锁，共享资源并发控制开销 Redis大部分操作在内存中完成的 高效的数据结构，使用一个全局哈希表，底层数据结构高效，如使用哈希表和跳表。 多路复用机制的IO模型 3、 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/AOF日志.html":{"url":"Redis/AOF日志.html","title":"3、AOF日志","keywords":"","body":"AOF日志 Redis如何实现数据持久化，Redis服务器宕机，如何恢复数据 Redis的持久化主要有两大机制，即AOF日志和RDB快照 AOF日志与数据库日志相反，它是写后日志，即Redis先执行命令，把数据写入内存，然后才记录日志。传统数据库日志，如redo log ,记录的是修改后的数据，AOF记录的是Redis 收到的每条命令。 好处：只有命令执行成功才记录日志，避免出现记录错误的日志，命令执行后才记录日志，所以不会阻塞当前的写操作。 AOF日志潜在的两个风险点 执行完命令后，没来得及记录日志，服务器宕机了，就无法用日志进行恢复了 AOF虽然避免了当前写操作，但可能会给下一个操作带来阻塞风险，因为AOF在主线程中执行，日志文件写磁盘的慢可能会导致后续操作无法执行。 针对改问题的解决办法 AOF日志的三种写回策略 Always 同步写回，每个命令执行完，立马同步的将日志写回磁盘。 EverySec 每秒写回，每个命令执行完，先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区的内容写入磁盘。 No 操作系统控制的写回，每个命令执行完，先把日志写到AOF文件的内存缓冲区，由操作系统决定何时写入磁盘。 三种写回策略的优缺点。 高性能选No策略、高可靠选Always策略、折中选每秒写回策略。 仍然存在的风险点，AOF文件过大带来的性能问题。 文件系统本身对文件大小的限制，无法保存过大文件 文件太大，追加命令效率低下。 发生宕机，日志文件过大，恢复时间长，影响Redis正常使用 AOF日志文件过大解决办法：AOF日志重写 日志重写，就是将Redis多条命中合并为一条命中，忽略中间过程，保证最终结果的一致性。在日志恢复时，只要执行这条命令，就可以恢复。 AOF日志重写会阻塞吗？ 和AOF日志由主线程写回不同，AOF日志重写是由后台线程bgrewriteaof来完成的，是为了避免阻塞主线程。 日志重写过程： 一处拷贝： 主线程fork出后台子线程后，主线程内存拷贝一份给子线程，子线程将拷贝的数据重写入日志。 两处日志： 正在使用的AOF日志与AOF重写日志 重写日志过程 总结 1、 AOF日志重写过程中潜在的风险点。 重写时，主线程会fork一个子线程进行处理，fork子线程可能存在阻塞主线程的风险。 读写操作bigkey风险 2、 AOF重写也有一个重写日志，为什么不共享使用AOF本身的日志呢。 如果都使用AOF日志的话，主线程要写，子线程也要写，两者会竞争文件系统的锁，会对主线程性能造成影响。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/Redis内存快照RDB.html":{"url":"Redis/Redis内存快照RDB.html","title":"4、Redis内存快照RDB","keywords":"","body":"Redis内存快照RDB Redis服务器宕机，可以使用AOF日志进行恢复，如果AOF日志过大，故障恢复时间过长，影响到Redis的正常使用。 这里我们讨论Redis的另外一种持久化方式，RDB快照，所谓内存快照，就是指内存中的数据在某一时间的状态记录。快照文件称为RDB文件(Redis DataBase) 与AOF的区别是，AOF记录的是操作命令，RDB记录的是某一时刻的数据，并不是操作，在做数据恢复时，可以直接将RDB文件读入内存，实现快速恢复。 关键问题： 对哪些数据做快照，快照的执行效率。 全量快照,对所有数据做快照。 做快照时，还能进行增删改查吗，关系到Redis是否阻塞，能否同时处理正常请求。 Redis如何生成RDB文件 save: 在主线程中执行，会导致阻塞。 bgsave: 创建一个子线程,专门用于写入RDB文件，避免阻塞主线程，Redis默认配置。 快照时数据能修改吗？ 快照时数据能修改，Redis借助操作系统提供的写时复制技术(Copy-On-Write)在执行快照的同事，支持处理写操作 主线程在子线程执行RDB操作的时候修改了数据，会生成修改数据的副本，子线程读取副本写入RDB文件。 写时复制过程 Redis多久做一次快照 频繁的做全量快照，会带来两方面的开销，已方面，频繁将全量数据写入磁盘，给磁盘带来很大的压力，多个快照竞争有限的磁盘宽带，前一个快照还没做完，后一个又来了，容易造成恶心循环，另已方面，bgsave子线程需要通过fork操作从主线程创建出来， fork过程会造成主线程阻塞，频繁fork会阻塞主线程。 解决办法：做一次全量快照后，后续的快照只对修改的数据进行快照记录，我们只需要记住哪些数据被修改了。 到这里你可能发现了，虽然和AOF相比，快照的恢复速度快，但是快照的频率不好把握，如果频率过低，数据丢失会多，频率高的话又有额外开销。 混合使用AOF日志和内存快照 内存快照以一定的评率执行，在两次快照之间，使用AOF日志记录这期间所有命令操作。 该方法的优点： 快照不用频繁的执行，避免了频繁fork对主线程的影响。 AOF日志只记录两次快照之间的操作，不会出现AOF文件过大的情况，也避免了AOF重新带来的开销。 小结 RDB文件的优势在于，可以快速恢复数据库，只需要把RDB文件直接读入内存，这样可以避免AOF需要顺序、逐一重新执行命令带来的低效性能问题。 使用AOF还是RDB快照?选型问题 数据不能丢失，内存快照和AOF的混合使用是一个很好的选择 如果允许分钟级别的数据丢失，可以只使用RDB 如果只使用AOF,优先使用everysec的 配置选项，因为他在可靠性和性能直接取了一个平衡。 总结 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/Redis数据同步：主从数据一致性问题.html":{"url":"Redis/Redis数据同步：主从数据一致性问题.html","title":"5、Redis数据同步：主从数据一致性问题","keywords":"","body":"Redis数据同步：主从数据一致性问题 AOF和RDB ，如果Redis发生了宕机，他们可以分别通过回放日志和重新读入RDB文件的方式恢复数据，保证尽量少丢失数据，提升可靠性。 如果我们只运行了一个Redis实例，如果实例宕机了，故障恢复期间就不可用，无法处理新来的数据请求。 为解决上述问题，Redis的做法就是增加副本冗余量，将一份数据同时保存在多个实例上，一个实例宕机，其它实例还可以正常提供服务。 Redis 主从模式 主从库之间采用的是读写分离模式 读操作： 主库、从库都可以接收 写操作： 首先到主库执行，然后，主库将写操作同步给从库。(为了避免主从数据一致性问题，同时写主库与从库，涉及到加锁等额外开销操作) 主从库直接如何进行第一次同步 第一阶段：从库和主库建立连接，并告诉从库即将进行同步，主库确认回复后，主从库就可以开始同步了。 第二阶段：主从将所有数据同步给从库，从库收到数据后，在本地完成数据加载，这个过程依赖内存快照生成的RDB文件。主从执行bgsave命令生成RDB文件发给从库，从库 清空当前数据库，再加载RDB文件 第三阶段：同步过程中，主库仍然正常接收客户端请求，将这些第二阶段的请求放在缓冲区，完成RDB文件发送后，将缓冲区的修改操作再发给从库，主从库就实现同步了。 主从级联模式分担全量复制时主库压力 主从同步有两个耗时操作：生成RDB文件和传输RDB文件，如果从库数量多，都与主库进行全量复制的话，主库忙于fork子进程生成RDB文件，进行全量同步，fork操作会阻塞主线程 进行处理正常请求，传输RDB文件也会占用主库网络带宽。 解决办法：通过主-从-从模式将主库生成的RDB和传输RDB的压力，以级联的方式分散到从库上，完成全量复制后，主从库之间就会维护一个网络连接，通过这个 连接将后续的命令同步给从库，这个过程称为基于长连接的命令传播。 级联主-从-从同步方式 主从库间网络断连 Redis2.8之前，会重新进行一次全量复制，2.8之后，采用增量复制的方式继续同步，主库会记录自己写到的位置，从库会记录自己已经读到。 增量复制过程 小结 主从同步基本原理，有三种模式，全量复制(第一次主从同步)、基于长连接的命令模式(第一次同步后续同步)、增量复制(网络断连的情况下)。 总结 1、主从同步使用的是RDB快照文件的方式进行同步，AOF记录的操作命令更全，相比RDB丢失的数据更少，为什么不使用AOF日志进行主从同步 RDB文件是二进制文件，无论是否把RDB写入磁盘还是通过网络传输RDB,IO效率都比记录和传输AOF的高 从库端恢复时，RDB恢复效率比AOF高 主从库同步存在的坑 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/哨兵机制、哨兵集群.html":{"url":"Redis/哨兵机制、哨兵集群.html","title":"6、哨兵机制、哨兵集群","keywords":"","body":"6、哨兵机制、哨兵集群 主库挂了，如何不间断的提供服务 如果主库挂了，客户端读操作还可以由其他从库继续提供服务， 如果是写操作请求，按照读写分离模式，写操作由主库完成，主库挂了，写服务就中断了，也无法进行主从同步工作了。 解决办法：主库挂了，需要运行一个新主库，比如讲一个从库切换为主库，这里存在有三个问题 主库真的挂了吗 选取哪个从库作为新的主库 怎么将新主库信息同步给客户端与其他从库 哨兵机制的基本流程 哨兵其实就是一个运行在特殊模式的Redis进程，主要负责三个任务：监控、选主、通知 监控：哨兵周期性的给所有主从库发送PING命令，检测他们是否仍在运行。如果无响应，哨兵会标记为下线状态，主库无响应，会进行自动切换主库流程。 选主：哨兵按照一定规则从多个从库中选择一个从库作为新的主库，然后集群中就有了新的主库。 通知：哨兵将新主库信息发给其它从库，让他们执行replicaof命令,和新主库建立连接并进行数据复制，同时哨兵会把新主库连接信息通知给客户端，让客户端将请求发到新主库上。 主观下线和客观下线 哨兵进程会PING命令检测它与主库、从库的网络连接情况，来判断实例的状态。如果从库响应超时，就标记为主观下线，从库下线，影响不会太大 如果检测的是主库，主库响应超时了，哨兵不能简单的把主库标记为主观下线，因为可能存在误判的情况，主库的切换，后续选主和通知会带来不小的通信开销。 什么原因会导致误判？如果集群网络压力大，网络拥塞，或者主库本身压力大的情况下就可能出现误判。 解决办法：哨兵使用多个实例组成的集群模式进行部署，简称哨兵集群，通过哨兵集群投票决定，少数服从多数原则。 选主新库规则 首先检查从库的当前在线状态，下线了的从库过滤掉，再判断它之前的网络连接状态，然后总是和旧主库断开连接，就筛选掉。 对接下来的从库进行打分，得分最高的就是新的主库 第一轮：优先级最高的从库得最高分(redis 配置项可以配置优先级) 第二轮：和旧从库同步程度最接近的从库得分高 第三轮：ID号小的从库得分高 哨兵集群的关键机制 基于pub/sub机制的哨兵集群组成过程，哨兵在主库上发布自己的连接信息，也可以从主库上订阅消息，多个哨兵就知道了彼此的链接信息，可以进行通信。 哨兵向主库发送INFO命令，主库会把从库列表返回给哨兵，哨兵再与从库建立连接。 基于哨兵自身的pub/sub功能，实现了客户端与哨兵直接的事件通知。 总结 1、通过哨兵机制，可以实现主从库自动切换，主从库切换需要一定时间，这期间能否正常处理客户端请求？如果想要客户端不感知服务中断，还需要哨兵和客户端做什么工作。 一方面，客户端需要能缓存应用发送的写请求。只要不是同步写操作（Redis 应用场景一般也没有同步写），写请求通常不会在应用程序的关键路径上，所以，客户端缓存写请求后，给应用程序返回一个确认就行 主从切换完成后，客户端要能和新主库重新建立连接，哨兵需要提供订阅频道，让客户端能够订阅到新主库的信息。同时，客户端也需要能主动和哨兵通信，询问新主库的信息。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/切片集群.html":{"url":"Redis/切片集群.html","title":"7、切片集群","keywords":"","body":"7、切片集群 Redis如何保存更多的数据？ 纵向扩展：升级单个Redis实例资源，包括内存容量，磁盘容量，CPU等。 横向扩展：增加当前Redis实例的个数. 这两种方式的优缺点： 纵向扩展优点：实施简单，直接。 纵向扩展缺点：使用RDB对数据持久化时，数据量的增加，需要的内存也会增加，fork子线程的时候可能会阻塞，纵向扩展会受硬件和成本限制。 横向扩展： 数据切片后，在多个实例间如何分布 客户端怎么确定想要访问的数据在哪个实例上。 数据片和实例的对应分布关系 Redis Cluster方案采用哈希槽来处理实例和数据之间的映射关系，方案中，一个切片集群共有16384个哈希槽，类似于数据分区，每个键值都会根据它的key,被映射到一个哈希槽 映射过程：CRC16算法计算一个16bit的值，再用这个16bit的值对16385取模，得到0-16383范围内的数， 分配到对应的哈希槽位置。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/异步机制：如何避免单线程模型的阻塞.html":{"url":"Redis/异步机制：如何避免单线程模型的阻塞.html","title":"8、异步机制：如何避免单线程模型的阻塞","keywords":"","body":"8、异步机制：如何避免单线程模型的阻塞 Rdis实例有哪些阻塞点 客户端：网络IO,键值对增删改查操作、数据库操作 磁盘：生成RDB快照、记录AOF日志、AOF日志重写 主从节点：主库生成、传输RDB文件、从库接收RDB文件、清空数据库、加载RDB文件 切片集群实例：向其他实例传输哈希槽信息、数据迁移。 1、和客户端交互时的阻塞点：集合全量查询和聚合操作、bigKey删除操作、清空数据库。 2、和磁盘交互时的阻塞点：AOF日志同步写 3、主从节点交互时的阻塞点：从库加载RDB文件 哪些阻塞点可以异步操作 一个操作可以被异步执行，就意味着，它并不是主线程上的关键路径上的操作，结果不需要立即响应给客户端，比如读操作时典型的关键路径上的操作，因为 客户端强依赖返回结果。 对于 Redis 的五大阻塞点来说，除了“集合全量查询和聚合操作”和“从库加载 RDB 文件”，其他三个阻塞点涉及的操作都不在关键路径上，所以，我们可以使用 Redis 的异步子线程机制来实现 bigkey 删除，清空数据库，以及 AOF 日志同步写 异步的子线程机制 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/如何应对变慢的Redis.html":{"url":"Redis/如何应对变慢的Redis.html","title":"9、如何应对变慢的Redis","keywords":"","body":"9、如何应对变慢的Redis 从文件系统和操作系统两个方面解决Redis变慢问题 获取 Redis 实例在当前环境下的基线性能。 是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。 是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。 是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。 Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入 Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。 在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。 是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/Redis缓存淘汰策略.html":{"url":"Redis/Redis缓存淘汰策略.html","title":"10、Redis缓存淘汰策略","keywords":"","body":"10、Redis缓存淘汰策略 Redis缓存有哪些淘汰策略 Redis提供了8中缓存淘汰策略 在设置了过期时间的数据中淘汰 volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。 volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。 volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。 volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对。 在所有数据中淘汰 allkeys-random 策略，从所有键值对中随机选择并删除数据； allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选 allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。 LRU算法 概念：LRU 算法的全称是 Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。 过程：LRU会把所有数据组织成一个链表，链表头和和链表尾分别表示MRU端和LRU端，分别表示最近最常使用和最近不常用的数据，当缓存满了或者到达阈值，就将LRU端的数据淘汰。 缺点：LRU算法实现时，需要使用链表管理所有缓存数据，这会带来额外的空间开销。大量的数据访问，会频繁的进行移动链表操作，很耗时，降低了Redis缓存性能。 Redis简化采用方案：Redis默认记录每个数据最近一次访问时间戳(RedisObject中的lru字段记录)，在 redis决定进行淘汰数据时，随机选择N个数据作为候选集，redis会 比较候选集合中lru字段的大小，将最小的字段从缓存中淘汰出去。 这样一来，Redis缓存不用为所有数据维护一个链表，也不用每次访问数据时都移动链表，提升了缓存性能。 建议策略 优先使用allkeys-lru策略 数据访问频率相差不大，没有冷热数据区分，建议使用allkeys-random策略，随机淘汰即可。 置顶需求，可以使用volititle-lru策略，对置顶数据不设置过期时间，其它数据设置过期时间，根据lru策略进行淘汰 LUR算法实现 public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode prev; DLinkedNode next; public DLinkedNode() {} public DLinkedNode(int _key, int _value) {key = _key; value = _value;} } private Map cache = new HashMap(); private int size; private int capacity; private DLinkedNode head, tail; public LRUCache(int capacity) { this.size = 0; this.capacity = capacity; // 使用伪头部和伪尾部节点 head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.prev = head; } public int get(int key) { DLinkedNode node = cache.get(key); if (node == null) { return -1; } // 如果 key 存在，先通过哈希表定位，再移到头部 moveToHead(node); return node.value; } public void put(int key, int value) { DLinkedNode node = cache.get(key); if (node == null) { // 如果 key 不存在，创建一个新的节点 DLinkedNode newNode = new DLinkedNode(key, value); // 添加进哈希表 cache.put(key, newNode); // 添加至双向链表的头部 addToHead(newNode); ++size; if (size > capacity) { // 如果超出容量，删除双向链表的尾部节点 DLinkedNode tail = removeTail(); // 删除哈希表中对应的项 cache.remove(tail.key); --size; } } else { // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部 node.value = value; moveToHead(node); } } private void addToHead(DLinkedNode node) { node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; } private void removeNode(DLinkedNode node) { node.prev.next = node.next; node.next.prev = node.prev; } private void moveToHead(DLinkedNode node) { removeNode(node); addToHead(node); } private DLinkedNode removeTail() { DLinkedNode res = tail.prev; removeNode(res); return res; } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/缓存一致性问题.html":{"url":"Redis/缓存一致性问题.html","title":"11、缓存一致性问题","keywords":"","body":"11、缓存一致性问题 如何解决缓存和数据库的数据不一致问题 缓存和数据库数据不一致是如何发生的 缓存一致性概念：缓存中有数据，那么缓存中的数据值需要和数据库中的数据值相同，缓存中本身没有数据,那么数据库中的值必须是最新的值。 读写缓存 同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致。 异步写回策略：写缓存时候不同步写数据库，等到数据从缓存中淘汰时，再写回数据库，使用这种策略时，如果数据还没写回数据库，缓存就发生了故障，那么此时数据库就没有最新数据了。 使用事物机制，写缓存时同时写数据库，来保证缓存和数据库的更新具有原子性，避免数据不一致问题。 如果对数据一致性要求不高，比如修改一下非关键性属性，可以使用异步写回策略。 只读缓存 新增、删除、修改数据，都会直接在数据库中进行操作，删除、修改数据时，还会将缓存中的数据删除，置位无效。 新增数据的情况，数据直接写到数据库中，不对缓存做任何操作，缓存中本身没有新增的数据，缓存和数据库的数据是一致的。 删改数据的情况，删改数据，需要更新数据库，同时需要在缓存中删除数据，如果两个操作无法保证原子性，就会存在数据不一致的问题。无论先操作缓存还是先操作数据库 只要有一个失败了，就会存在数据不一致问题，和操作顺序无关。 如何解决数据不一致问题 方案一：重试机制，把要删除或者更新的值暂存在消息队列中，比如kafka,当删改失败，从消息队列中重新读取，再进行删改操作，如果删改成功，将消息去除，避免重复操作，如果失败 进行重试，重试一定次数还是失败，将错误信息抛出给业务层，记录错误日志，后续进行数据恢复。 *情况一：先删除缓存、再更新数据库 解决办法：延迟双删 redis.delKey(x) db.update(x) Thread.sleep(n) redis.delKey(x) 情况二：先更新数据库值，再删除缓存值 解决方案： 删除缓存值或更新数据库失败而导致数据不一致，你可以使用重试机制确保删除或更新操作成功 在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删 小结 建议使用优先删除数据库，再删除缓存的方法； 先删除缓存再更新数据库，有可能导致瞬间访问数据库的量太大，导致数据库压力过大。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/缓存雪崩、缓存击穿、缓存穿透问题.html":{"url":"Redis/缓存雪崩、缓存击穿、缓存穿透问题.html","title":"12、缓存雪崩、缓存击穿、缓存穿透问题","keywords":"","body":"12、缓存雪崩、缓存击穿、缓存穿透问题 缓存雪崩 概念：缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。 导致缓存雪崩的原因： 第一个原因：缓存中有大量的数据同时过期，导致大量请求无法得到处理。 解决方案： 微调过期时间，设置过期时间时，给这些数据的过期时候增加一个较小的随机数，可以避免大量数据同一时间过期，也保证了这些数据基本在相近的过期时间内。 服务降级： 当访问的是非核心数据时，比如评论、商品属性、暂停从缓存中查询这些数据，而是直接返回预定义的值或者错误信息，不去请求redis，如果访问的是 核心数据时，比如商品库存，仍然允许查询缓存，缓存缺失，也可以通过数据库进行查询。 第二个原因：Redis缓存实例发生宕机了，无法处理请求，所有请求都打到了数据库上，发生缓存雪崩。 解决方案： 在业务系统中实现服务熔断或者请求限流机制。暂停数据库请求访问缓存和数据库，等实例恢复服务后，再允许将请求发送到缓存。 请求限流：比如设置每秒请求量最多为1000，大于1000的请求直接拒绝服务，比如提示网络繁忙，请稍后重试。 事前预防：构建redis高可靠集群，主节点宕机，进行主从切换。 缓存击穿 概念：缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。缓存击穿的情况，经常发生在热点数据过期失效时。 解决办法：对于访问特别频繁的热点数据，就不设置过期时间了。 缓存穿透 概念：缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，来服务后续请求，这样一来，缓存也就成了“摆设”，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力。 缓存穿透发生的场景 业务层操作错误，缓存中的数据和数据库中的数据被误删除了，所以缓存中和数据库中没有数据。 恶意攻击,专门访问数据库中没有的数据。 解决方案： 缓存空值或者缺省值，一旦发生缓存穿透 ，针对查询的数据，我们可以在redis中缓存一个空值或者缺省值，后续操作读取空值或者缺省值。 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。 前端进行请求检测，拦截掉恶意请求。 小结 事前预防，使用预安，服务熔断、服务降低、服务限流都对业务系统存在一定的影响，影响用户体验。 针对缓存雪崩、合理设置数据过期时间、搭建高可用缓存集群。 针对缓存击穿、在缓存访问非常频繁的热点数据时、不设置数据过期时间。 针对缓存穿透、提前在入口前端做好充分的恶意请求检测、拦截恶意请求，规范数据库的删除操作、避免出现误操作。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/Redis如何应对并发访问.html":{"url":"Redis/Redis如何应对并发访问.html","title":"13、Redis如何应对并发访问","keywords":"","body":"13、Redis如何应对并发访问 解决并发访问办法： 加锁和原子操作，加锁会降低系统的并发性能。 Redis的两种原子操作方法 为了实现并发控制要求的临界区代码互斥执行，Redis的原子操作采用了两种方法 把多个操作在Redis中实现成一个操作，也就是单命令操作 把多个操作写到一个Lua脚本中，以原子方式执行单个Lua脚本 如何使用Redis实现分布式锁 实现分布式锁的两个要求 分布式锁的加锁和释放锁的过程，设计多个操作、所以在实现分布式锁时，我们需要保障这些锁操作的原子性。 共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了，在实现分布式锁时，我们需要保障共享存储系统的可靠性，进而保障锁的可靠性。 基于单个redis实现分布式锁 //加锁 SETNX lock_key 1 //业务逻辑 DO THINGS //释放锁 DEL lock_key 给锁设置过期时间 区分来自不同的锁操作 基于多个redis节点实现高可靠的分布式锁 客户端获取当前时候 客户端按顺序依次向N个Redis实例执行加锁操作 一旦客户端完成了和所有Redis实例的加锁操作，客户端就要计算整个加锁过程的总耗时。 小结 分布式锁是由共享存储系统维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作。Redis 作为一个共享存储系统，可以用来实现分布式锁。 在基于单个 Redis 实例实现分布式锁时，对于加锁操作，我们需要满足三个条件。 加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁； 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间； 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。 和加锁类似，释放锁也包含了读取锁变量值、判断锁变量值和删除锁变量三个操作，不过，我们无法使用单个命令来实现，所以，我们可以采用 Lua 脚本执行释放锁操作，通过 Redis 原子性地执行 Lua 脚本，来保证释放锁操作的原子性。 不过，基于单个 Redis 实例实现分布式锁时，会面临实例异常或崩溃的情况，这会导致实例无法提供锁操作，正因为此，Redis 也提供了 Redlock 算法，用来实现基于多个实例的分布式锁。这样一来，锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。Redlock 算法是实现高可靠分布式锁的一种有效解决方案，你可以在实际应用中把它用起来。 、 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Redis/Redis脑裂.html":{"url":"Redis/Redis脑裂.html","title":"14、Redis脑裂","keywords":"","body":"14、Redis脑裂 所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。 脑裂经常会发生数据丢失 为什么会发生脑裂 第一步：确认是不是数据同步出现了问题 主库的数据还没有同步到从库，结果主库发生了故障，等从库升级为主库后，未同步的数据就丢失了。 脑裂发生的过程 为什么脑裂会丢失数据 主从切换后，从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步。而在全量同步执行的最后阶段，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，这样一来，原主库在主从切换期间保存的新写数据就丢失了。 如何应对脑裂问题 min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量； min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。 脑裂主库假故障原因 和主库部署在同一台服务器上的其他程序临时占用了大量资源（例如 CPU 资源），导致主库资源使用受限，短时间内无法响应心跳。其它程序不再使用资源时，主库又恢复正常。 主库自身遇到了阻塞的情况，例如，处理 bigkey 或是发生内存 swap, 短时间内无法响应心跳，等主库阻塞解除后，又恢复正常的请求处理了. © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/Kafka.html":{"url":"简介/Kafka.html","title":"Kafka","keywords":"","body":"Kafka © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Kafka/kafka消息架构.html":{"url":"Kafka/kafka消息架构.html","title":"kafka消息架构","keywords":"","body":"kafka消息架构 生产者消息分区机制原理剖析 Kafka轮询策略:轮询策略是Kafka Java生产者API默认提供的分区策略。如果你未指定partitioner.class参数，那么你的生产者程序会按照轮询的方式在主题的所有分区间均匀地“码放”消息, 轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们最常用的分区策略之一。 随机策略:也称Randomness策略。所谓随机就是我们随意地将消息放置到任意一个分区上. 按消息键保序策略: 生产者压缩算法 在生产者启用压缩算法，使用gzip压缩，生产者端启用压缩，在Broker端也可能进行压缩 Properties props = new Properties(); props.put(\"bootstrap.servers\", \"localhost:9092\"); props.put(\"acks\", \"all\"); props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); // 开启GZIP压缩 props.put(\"compression.type\", \"gzip\"); Producer producer = new KafkaProducer<>(props); 总结：Producer端压缩、Broker端保持、Consumer端解压缩 如何配置Kafka无消息丢失 一句话概括，Kafka只对“已提交”的消息（committed message）做有限度的持久化保证 Producer永远要使用带有回调通知的发送API，也就是说不要使用producer.send(msg)，而要使用producer.send(msg, callback) 解决消费者程序丢失数据:维持先消费消息，再更新位移的顺序。 如果是多线程异步处理消费消息，Consumer程序不要开启自动提交位移，而是要应用程序手动提交位移 总结：最佳实践 不要使用producer.send(msg)，而要使用producer.send(msg, callback)。记住，一定要使用带有回调通知的send方法 设置acks = all。acks是Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成all，则表明所有副本Broker都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。 设置retries为一个较大的值。这里的retries同样是Producer的参数，对应前面提到的Producer自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了retries > 0的Producer能够自动重试消息发送，避免消息丢失 设置unclean.leader.election.enable = false 设置replication.factor >= 3。这也是Broker端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余 设置min.insync.replicas > 1。这依然是Broker端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于1可以提升消息持久性。在实际环境中千万不要使用默认值1。 确保replication.factor > min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成replication.factor = min.insync.replicas + 1 确保消息消费完成再提交。Consumer端有个参数enable.auto.commit，最好把它设置成false，并采用手动提交位移的方式。就像前面说的，这对于单Consumer多线程处理的场景而言是至关重要的。 Kafka拦截器 Kafka拦截器分为生产者拦截器和消费者拦截器 Kafka拦截器可以应用于包括客户端监控、端到端系统性能检测、消息审计等多种功能在内的场景 Java生产者是如何管理TCP连接的 KafkaProducer实例创建时启动Sender线程，从而创建与bootstrap.servers中所有Broker的TCP连接 KafkaProducer实例首次更新元数据信息之后，还会再次创建与集群中所有Broker的TCP连接 如果Producer端发送消息到某台Broker时发现没有与该Broker的TCP连接，那么也会立即创建连接。 如果设置Producer端connections.max.idle.ms参数大于0，则步骤1中创建的TCP连接会被自动关闭；如果设置该参数=-1，那么步骤1中创建的TCP连接将无法被关闭，从而成为“僵尸”连接。 Producer端关闭TCP连接的方式有两种：一种是用户主动关闭；一种是Kafka自动关闭。 Kafka消息交付可靠性保障以及精确处理一次语义的实现。 最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。 至少一次（at least once）：消息不会丢失，但有可能被重复发送。 精确一次（exactly once）：消息不会丢失，也不会被重复发送。 kafka默认提供的交付可靠保障是第二针：至少一次。 Kafka如何做到精确一次的消息交付：这是通过两种机制：幂等性（Idempotence）和事务（Transaction） 幂等性Producer只能保证单分区、单会话上的消息幂等性；而事务能够保证跨分区、跨会话间的幂等性。从交付语义上来看，自然是事务型Producer能做的更多。 消费者组到底是什么 Kafka中位移提交那些事儿 Kafka Consumer的位移提交，是实现Consumer端语义保障的重要手段。位移提交分为自动提交和手动提交，而手动提交又分为同步提交和异步提交。在实际使用过程中，推荐你使用手动提交机制，因为它更加可控，也更加灵活。另外，建议你同时采用同步提交和异步提交两种方式，这样既不影响TPS，又支持自动重试，改善Consumer应用的高可用性。总之，Kafka Consumer API提供了多种灵活的提交方法，方便你根据自己的业务场景定制你的提交策略。 Kafka副本机制详解 所谓的副本机制（Replication），也可以称之为备份机制，通常是指分布式系统在多台网络互联的机器上保存有相同的数据拷贝。副本机制有什么好处呢？ 提供数据冗余。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性。 提供高伸缩性。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量。 改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/Java基础与进阶.html":{"url":"简介/Java基础与进阶.html","title":"Java基础与进阶","keywords":"","body":"Java基础与进阶 线程池 import java.util.Date; import java.util.concurrent.*; public class ThreadPoolDemo { private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int QUEUE_CAPACITY = 100; private static final Long KEEP_ALIVE_TIME = 1L; private static ThreadPoolDemo instance = null; private ExecutorService executors; static { instance = new ThreadPoolDemo(); } private ThreadPoolDemo() { executors = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue<>(QUEUE_CAPACITY), new ThreadPoolExecutor.CallerRunsPolicy()); } public void executeTask(Runnable task) { executors.execute(task); } public static ThreadPoolDemo getInstance() { return instance; } public static void main(String[] args) { for (int i = 0; i { System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date()); }); } } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/Java基础知识.html":{"url":"简介/Java基础知识.html","title":"Java基础知识","keywords":"","body":"Java基础知识 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/Java集合框架.html":{"url":"Java基础知识/Java集合框架.html","title":"Java集合框架","keywords":"","body":"Java集合框架 对比 Vector、ArrayList、LinkedList 有何区别？ Vector 是 Java 早期提供的线程安全的动态数组，Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。 Vector 在扩容时会提高 1 倍，比如当前容量为10，扩容后变成20，而 ArrayList 则是增加 50% ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，ArrayList 也是可以根据需要调整容量，扩容增加50%。 Vector 与ArrayList 作为动态数据，内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。 LinkedList 是基于双向链表实现的 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。 集合框架 List，也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作 Set，Set 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合 Queue/Deque，则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。 ArrayList 不是线程安全的，如何实现线程安全的ArrayList？ 方法一 ：同步的ArrayList方法 它的实现，基本就是将每个基本方法，比如 get、set、add 之类，都通过 synchronizd 添加基本的同步支持 List objects = Collections.synchronizedList(new ArrayList<>()); 方法二 CopyOnWriteArrayList CopyOnWriteArrayList copyOnWriteArrayList = new CopyOnWriteArrayList<>(); 两种方法的区别： CopyOnWriteArrayList的写操作性能较差，而多线程的读操作性能较好。而Collections.synchronizedList的写操作性能比CopyOnWriteArrayList在多线程操作的情况下要好很多，而读操作因为是采用了synchronized关键字的方式，其读操作性能并不如CopyOnWriteArrayList。 CopyOnWriteArrayList适合读多写少的场景，Collections.synchronizedList适合读写比较均衡的场景，Collections.synchronizedList性能较均衡。 数组默认排序方式与设计思路 数组排序方式 //数组排序 Arrays.sort(new int[]{1,5,4}); //List 排序 List list = new ArrayList<>(); Collections.sort(list); Collections.sort() 底层是调用 Arrays.sort() 对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序，你可以阅读源码。 而对于对象数据类型，目前则是使用TimSort，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。 对比 Hashtable、HashMap、TreeMap 有什么不同？ Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。 Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。 HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。 TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？ Java提供了不同层面的线程安全支持，除了HashTable同步容器，还提供了同步包容器（Synchronized Wrapper),我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap）,调用Collections.synchronizedList(new ArrayList<>())实现线程安全的list.但这种方法是非常粗粒度的同步方式，高并发下性能不高. 普通选择利用并发包下提供的线程安全容器类，性能更高。 各种并发容器， 比如 ConcurrentHashMap、CopyOnWriteArrayList。 各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。 如何正确的将数组转换为ArrayList? List list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\")) java8 Integer [] myArray = { 1, 2, 3 }; List myList = Arrays.stream(myArray).collect(Collectors.toList()); //基本类型也可以实现转换（依赖boxed的装箱操作） int [] myArray2 = { 1, 2, 3 }; List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); 使用 Apache Commons Collections List list = new ArrayList(); CollectionUtils.addAll(list, str); 使用 Java9 的 List.of()方法 Integer[] array = {1, 2, 3}; List list = List.of(array); System.out.println(list); /* [1, 2, 3] */ Collection.toArray()方法使用的坑&如何反转数组 String [] s= new String[]{ \"dog\", \"lazy\", \"a\", \"over\", \"jumps\", \"fox\", \"brown\", \"quick\", \"A\" }; List list = Arrays.asList(s); Collections.reverse(list); s=list.toArray(new String[0]);//没有指定类型的话会报错 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/Java IO.html":{"url":"Java基础知识/Java IO.html","title":"Java IO","keywords":"","body":"Java IO 概念 Java IO 是一套Java用来读写数据（输入和输出）的API。大部分程序都要处理一些输入，并由输入产生一些输出。Java为此提供了java.io包 磁盘操作：File File 表示文件目录，但不表示文件内容，以下代码递归的展示一个目录下的所有文件 public static void main(String[] args) { listAllFiles(new File(\"/Users/gaohueric/Documents/SublimeWorkStation\")); } public static void listAllFiles(File dir) { if (dir == null || !dir.exists()) { return; } if (dir.isFile()) { System.out.println(dir.getName()); return; } for (File file : dir.listFiles()) { listAllFiles(file); } } 字节操作 文件拷贝的几种方式 实现文件复制,读取一个文件写入另外一个文件，将字符转换为字节，再写入文件。 public static void main(String[] args) throws IOException { FileInputStream fileInputStream = new FileInputStream(\"/Users/gaohueric/Documents/known_hosts\"); FileOutputStream fileOutputStream = new FileOutputStream(\"/Users/gaohueric/Documents/new_known_hosts\"); byte[] buffer = new byte[20*1024]; int cnt; while((cnt = fileInputStream.read(buffer,0,buffer.length)) != -1){ fileOutputStream.write(buffer,0,cnt); } fileInputStream.close(); fileOutputStream.close(); } 结果输出到文件 public static void main(String[] args) throws IOException { FileOutputStream fileOutputStream = new FileOutputStream(\"/Users/gaohueric/Documents/test.txt\"); for(int i=0;i 通过普通的缓冲输入输出流拷贝文件 public static void main(String[] args) throws IOException { InputStream in = null; OutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(\"/Users/gaohueric/Documents/known_hosts\")); out = new BufferedOutputStream(new FileOutputStream(\"/Users/gaohueric/Documents/new_test.txt\")); byte[] buffer = new byte[2048]; int i; while ((i = in.read(buffer)) != -1) { out.write(buffer, 0, i); } } catch (Exception e) { System.out.println(1); } finally { in.close(); out.close(); } } 通过文件管道的方式复制文件 基于NIO的方式 public static void main(String[] args) throws IOException { FileChannel in = new FileInputStream(\"/Users/gaohueric/Documents/known_hosts\").getChannel(); FileChannel out = new FileOutputStream(\"/Users/gaohueric/Documents/new_test.txt\").getChannel(); in.transferTo(0,in.size(),out); } 通过管道方式复制文件比缓冲流快了三分之一 原因分析：当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。 通过缓冲流方式会带来一定的上下文切换开销，会降低IO效率。 而基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。 字符操作 String的编码方式：编码与解码 String str1 = \"测试\"; byte[] bytes = str1.getBytes(\"UTF-8\"); String str2 = new String(bytes, \"UTF-8\"); System.out.println(str2); Reader 与 Writer 从文件中读取字节流，转换为字符 输出 InputStreamReader 实现从字节流解码成字符流； OutputStreamWriter 实现字符流编码成为字节流。 一下代码实现逐行输出文本文件的内容 public static void main(String[] args) throws IOException { FileReader fileReader = new FileReader(\"/Users/gaohueric/Documents/known_hosts\"); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while((line = bufferedReader.readLine()) != null){ System.out.println(line); } bufferedReader.close(); fileReader.close(); } IO模型 Java中IO系统可以分为BIO，NIO，AIO三种IO模型 BIO(blocking I/O) 同步阻塞IO BIO是同步阻塞IO，JDK1.4之前只有这一个IO模型，BIO操作的对象是流，一个线程只能处理一个流的IO请求，如果想要同时处理多个流就需要使用多线程 NIO(Non-blocking I/O) 同步非阻塞IO,服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 AIO(NIO.2) (Asynchronous I/O) 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理. © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/反射.html":{"url":"Java基础知识/反射.html","title":"反射","keywords":"","body":"反射的概念 反射最大的作用之一就在于我们可以不在编译时知道某个对象的类型，而在运行时通过提供完整的”包名+类名.class”得到。注意：不是在编译时，而是在运行时。 反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 反射机制的功能 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 生成动态代理。 实现反射机制的类 Java中主要由以下的类来实现Java反射机制（这些类都位于java.lang.reflect包中）： Class类：代表一个类。 Field类：代表类的成员变量（成员变量也称为类的属性）。 Method类：代表类的方法。 Constructor类：代表类的构造方法 Array类：提供了动态创建数组，以及访问数组的元素的静态方法。 动态代理 首先，它是一个代理机制，如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。其实很多动态代理场景，我认为也可以看作是装饰器（Decorator）模式的应用。 通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面。 下面是JDK动态代理的一个简单实例，在生产系统中，我们可以轻松扩展类似逻辑进行诊断、限流等。 定义一个接口 public interface Hello { void sayHello(); } 接口实现 public class HelloImpl implements Hello{ @Override public void sayHello() { System.out.println(\"hello world\"); } } 定义一个代理处理器 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class MyInvocationHandler implements InvocationHandler { private Object target; public MyInvocationHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"这里可以做限流、打日志等操作\"); Object invoke = method.invoke(target, args); return invoke; } } 调用, 这里我们不是直接调用 Hello 的方法，而是通过代理解耦的去调用，在代理中可以做一些其他操作，比如日志打点、限流、诊断等操作。 import java.lang.reflect.Proxy; public class MyDynamicProxy { public static void main(String[] args) { HelloImpl hello = new HelloImpl(); MyInvocationHandler handler = new MyInvocationHandler(hello); Hello proxyHello = (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(), HelloImpl.class.getInterfaces(), handler); proxyHello.sayHello(); } } 反射常用API 下面这个类用来演示Reflection API的基本使用方法。这里自定义的copy方法是用来创建一个和参数objcet同样类型的对象，然后把object对象中的所有属性拷贝到新建的对象中，并将其返回。 public class ReflectTester { public Object copy(Object object) throws Exception { Class classType = object.getClass(); //构造一个新的对象 Object objectCopy=classType.getConstructor(new Class[]{}).newInstance(new Object[]{}); //获取对象的所有属性 Field[] declaredFields = classType.getDeclaredFields(); for (Field field: declaredFields) { String name = field.getName(); String firstLetter = name.substring(0,1).toUpperCase(); //获得和属性对应的getXXX()方法的名字 String getMethodName = \"get\"+firstLetter+name.substring(1); //获得和属性对应的setXXX()方法的名字 String setMethodName=\"set\"+firstLetter+name.substring(1); //获得和属性对应的getXXX()方法 Method getMethod = classType.getMethod(getMethodName, new Class[]{}); //获得和属性对应的setXXX()方法 Method setMethod = classType.getMethod(setMethodName,new Class[]{field.getType()}); //调用原对象的getXXX()方法 Object value = getMethod.invoke(object, new Object[]{}); System.out.println(name+\":\"+value); //调用拷贝对象的setXXX()方法 setMethod.invoke(objectCopy,new Object[]{value}); } return objectCopy; } public static void main(String[] args) throws Exception { Student student = new Student(); student.setName(\"张三\"); Object copy = new ReflectTester().copy(req); System.out.println(copy); } } 获取反射中的Class对象 第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class clz = Class.forName(\"java.lang.String\"); 第二种，使用 .class 方法。 Class clz = String.class; 第三种，使用类对象的 getClass() 方法。 String str = new String(\"Hello\"); Class clz = str.getClass(); 通过反射创建类对象 第一种：通过 Class 对象的 newInstance() 方法。 Class clz = Student.class; Student student = (Student)clz.newInstance(); 第二种：通过 Constructor 对象的 newInstance() 方法 Class clz = Student.class; Constructor constructor = clz.getConstructor(); Student apple = (Student)constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。 Class clz = Student.class; Constructor constructor = clz.getConstructor(String.class, int.class); Student student = (Student)constructor.newInstance(\"张三\", 15); 通过反射获取类属性、方法、构造器 我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。 Class clz = Student.class; Field[] fields = clz.getFields(); for (Field field : fields) { System.out.println(field.getName()); } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/线程池.html":{"url":"Java基础知识/线程池.html","title":"线程池","keywords":"","body":"线程池 使用线程池的好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 如何创建线程池 Java通过Executors创建线程池的几种方式 newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行 newSingleThreadExecutor： 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.MINUTES, new ArrayBlockingQueue<>(QUEUE_CAPACITY), new ThreadPoolExecutor.AbortPolicy())：推荐使用ThreadPoolExecutor方法创建线程池。 Executors 返回线程池对象的弊端如下 FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。 线程池参数详解 int corePoolSize: 线程池的核心线程数 int maximumPoolSize:线程池的最大线程数 long keepAliveTime：当线程闲置时，保持线程存活的时间，默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize TimeUnit unit：keepAliveTime的时间单位 ThreadFactory threadFactory：线程工厂 BlockingQueue workQueue： 用来储存等待执行任务的队列 RejectedExecutionHandler handler：拒绝策略 线程池的拒绝策略 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略: ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求 线程池执行关系 使用方法： public class ThreadUtil { /** * 核心线程数 */ private static final int CORE_POOL_SIZE = 5; /** * 最大线程数 */ private static final int MAX_POOL_SIZE = 10; /** * 任务队列 */ private static final int QUEUE_CAPACITY = 100; /** *当线程数大于核心时，多余的空闲线程等待新任务的存活时间。 */ private static final Long KEEP_ALIVE_TIME = 1L; /** * 缓存线程池方式 */ private ExecutorService cacheThreadPool; /** * 定长线程池 */ private ExecutorService fixedThreadPool; /** * 单线程化线程池 */ private ExecutorService singleThreadPool; /** * 支持定时及周期性任务执行 */ private ExecutorService scheduledThreadPool; /** * threadPoolExecutor方式创建线程池 */ private ExecutorService threadPoolExecutor; /** * 单例获取线程池 * @return */ public static ThreadUtil getInstance(){ return ThreadPoolManagerHolder.instance; } private static class ThreadPoolManagerHolder { public static ThreadUtil instance = new ThreadUtil(); } private ThreadUtil(){ cacheThreadPool = Executors.newCachedThreadPool(); fixedThreadPool = Executors.newFixedThreadPool(3); singleThreadPool = Executors.newSingleThreadExecutor(); scheduledThreadPool = Executors.newScheduledThreadPool(5); threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.MINUTES, new ArrayBlockingQueue<>(QUEUE_CAPACITY), new ThreadPoolExecutor.AbortPolicy()); } public void executeTask(Runnable task){ threadPoolExecutor.execute(task); } public void cacheExecuteTask(Runnable task){ cacheThreadPool.execute(task); } public static void main(String[] args) { for(int i=0;i{ System.out.println(Thread.currentThread().getName()); }); } } } 例子2： public class ThreadLocalMain { private static final ThreadLocal threadLocal =new ThreadLocal<>(); private ExecutorService executorService; private ThreadLocalMain(){ executorService = new ThreadPoolExecutor(5,10,1L, TimeUnit.MINUTES, new ArrayBlockingQueue<>(20),new ThreadPoolExecutor.AbortPolicy()); } public static ThreadLocalMain getInstance(){ return ThreadPoolManageHolder.instance; } private static class ThreadPoolManageHolder{ public static ThreadLocalMain instance = new ThreadLocalMain(); } public void executorPool(Runnable task){ executorService.execute(task); } public static void main(String[] args) throws Exception { new ThreadLocalMain().execute(); } public void execute() throws Exception{ threadLocal.set(\"测试threadLocal\"); System.out.println(Thread.currentThread().getName()+\"线程中ThreadLocal的值:\"+threadLocal.get()); ThreadLocalMain.getInstance().executorPool(()->{ System.out.println(Thread.currentThread().getName()+\"线程中ThreadLocal的值:\"+threadLocal.get()); threadLocal.set(\"测试2\"); System.out.println(Thread.currentThread().getName()+\"重新设置后线程中ThreadLocal的值:\"+threadLocal.get()); System.out.println(Thread.currentThread().getName()+\"线程执行结束\"); threadLocal.remove(); System.out.println(Thread.currentThread().getName()+\"remove后线程中ThreadLocal的值:\"+threadLocal.get()); }); Thread.sleep(1000L); System.out.println(Thread.currentThread().getName()+\"线程中ThreadLocal的值:\"+threadLocal.get()); } } CountDownLatch实例 public class ThreadLocalMain { private static final ThreadLocal threadLocal =new ThreadLocal<>(); private ExecutorService executorService; private ThreadLocalMain(){ executorService = new ThreadPoolExecutor(5,10,1L, TimeUnit.MINUTES, new ArrayBlockingQueue<>(20),new ThreadPoolExecutor.AbortPolicy()); } public static ThreadLocalMain getInstance(){ return ThreadPoolManageHolder.instance; } private static class ThreadPoolManageHolder{ public static ThreadLocalMain instance = new ThreadLocalMain(); } public void executorPool(Runnable task){ executorService.execute(task); } public static void main(String[] args) throws Exception { new ThreadLocalMain().execute(); } public void execute() throws Exception{ final CountDownLatch latch = new CountDownLatch(3); for(int i=0;i{ System.out.println(\"子线程\" + Thread.currentThread().getName() + \"开始执行\"); try { Thread.sleep(30000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完成\"); latch.countDown();//当前线程调用此方法，则计数减一 }); } System.out.println(\"主线程\"+Thread.currentThread().getName()+\"等待子线程执行完成...\"); latch.await();//阻塞当前线程，直到计数器的值为0 System.out.println(\"主线程\"+Thread.currentThread().getName()+\"开始执行...\"); } } © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/分布式锁.html":{"url":"Java基础知识/分布式锁.html","title":"分布式锁","keywords":"","body":"分布式锁 基于数据库做分布式锁 基于乐观锁：利用表主键唯一或者唯一性约束做分布式锁 利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。 存在的问题： 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了 这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。 在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象 解决上面问题的方案： 数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍 非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。 非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。 比较好的办法是在程序中生产主键进行防重。 基于Redis做分布式锁 基于Redis的setnx()、expire()做分布式锁 setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。 expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。 setnx与expire 两个命令是非原子性的，可能出现死锁问题，使用set命名的原子操作可以实现分布式锁 set key value [EX seconds] [PX milliseconds] [NX|XX] 存在的问题： 锁误解除： 如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。 解决办法：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。 超时解锁导致并发：如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。 解决办法： 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。 另一种方式：使用开源框架Redisson实现分布式锁 Config config = new Config(); config.useClusterServers() .addNodeAddress(\"redis://192.168.31.101:7001\") .addNodeAddress(\"redis://192.168.31.101:7002\") .addNodeAddress(\"redis://192.168.31.101:7003\") .addNodeAddress(\"redis://192.168.31.102:7001\") .addNodeAddress(\"redis://192.168.31.102:7002\") .addNodeAddress(\"redis://192.168.31.102:7003\"); RedissonClient redisson = Redisson.create(config); RLock lock = redisson.getLock(\"anyLock\"); lock.lock(); lock.unlock(); Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行 Redisson 设置一个 Key 的默认过期时间为 30s，如果某个客户端持有一个锁超过了 30s 怎么办？ Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s。 这样的话，就算一直持有锁也不会出现 Key 过期了，其他线程获取到锁的问题了。 -Redisson 的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长 Key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁) 基于 Redlock 做分布式锁 基于ZK做分布式锁 分布式锁的思路是每个客户端都在某个目录下注册一个临时有序节点，每次最小的节点会获取锁，当前节点会去监听上一个较小节点，如果较小节点失效之后，就会去获取锁。 创建临时有序节点是公平锁，每次最小的节点获取锁。 监听锁的释放。由于是临时节点，zk断开的话节点会被删除，避免了死锁。 创建临时有序节点可以避免羊群效应。 创建单个节点是非公平锁，会存在羊群效应。 基于zookeeper实现和redis实现在性能上有什么差异 对于 Redis 的分布式锁而言，它有以下缺点： 它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。 另外来说的话，Redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮 Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。 所以使用 Redis 作为分布式锁也不失为一种好的方案，最重要的一点是 Redis 的性能很高，可以支撑高并发的获取、释放锁操作。 对于 ZK 分布式锁而言: ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。 如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。 但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/CAS详解.html":{"url":"Java基础知识/CAS详解.html","title":"CAS详解","keywords":"","body":"CAS详解 CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下 执行函数：CAS(V,E,N) 其包含3个参数 V表示要更新的变量,内存地址V 旧的预期值E N表示新值 如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新,CAS操作需要我们提供一个期望值， 当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下 CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题 并发包中的原子操作类(Atomic系列) AtomicBoolean：原子更新布尔类型 AtomicInteger：原子更新整型 AtomicLong：原子更新长整型 源码分析： public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // 获取指针类Unsafe private static final Unsafe unsafe = Unsafe.getUnsafe(); //下述变量value在AtomicInteger实例对象内的内存偏移量 private static final long valueOffset; static { try { //通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移 //通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } //当前AtomicInteger封装的int变量value private volatile int value; public AtomicInteger(int initialValue) { value = initialValue; } public AtomicInteger() { } //获取当前最新值， public final int get() { return value; } //设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。 public final void set(int newValue) { value = newValue; } //最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载 public final void lazySet(int newValue) { unsafe.putOrderedInt(this, valueOffset, newValue); } //设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法 public final int getAndSet(int newValue) { return unsafe.getAndSetInt(this, valueOffset, newValue); } //如果当前值为expect，则设置为update(当前值指的是value变量) public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } //当前值加1返回旧值，底层CAS操作 public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } //当前值减1，返回旧值，底层CAS操作 public final int getAndDecrement() { return unsafe.getAndAddInt(this, valueOffset, -1); } //当前值增加delta，返回旧值，底层CAS操作 public final int getAndAdd(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta); } //当前值加1，返回新值，底层CAS操作 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } //当前值减1，返回新值，底层CAS操作 public final int decrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, -1) - 1; } //当前值增加delta，返回新值，底层CAS操作 public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } //省略一些不常用的方法.... } 可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法 CAS的缺点 CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。do while循环一直尝试 不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。 ABA问题 CAS的ABA问题及其解决方案 AtomicStampedReference类:AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境 AtomicMarkableReference类:AtomicMarkableReference维护的是一个boolean值的标识，也就是说至于true和false两种切换状态,而对于AtomicMarkableReference来说只能减少ABA问题的发生概率，并不能杜绝。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/ES核心技术与实战.html":{"url":"Java基础知识/ES核心技术与实战.html","title":"ES核心技术与实战","keywords":"","body":"ES核心技术与实战 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/JVM.html":{"url":"简介/JVM.html","title":"JVM","keywords":"","body":"JVM JVM的组成构造 JVM主要由类加载器、运行时数据区、执行引擎三个部分组成。 程序计数器：记录程序执行的位置，有了程序计数器，就可以保证在涉及线程上下文切换的情景下，程序依然能够正确无误地运行下去。 Java虚拟机栈：存着程序运行时的局部变量，主要包含局部变量表、操作数栈。 本地方法栈：为native方法服务 方法区：线程共享，用于存储类的元信息、静态变量、常量、全局变量、普通方法的字节码等内容。 堆：线程共享、存储实例对象和数组 JVM的垃圾回收 JVM通过一种可达性分析算法(GC-ROOT)进行垃圾对象的识别，对象引用进行标记，没有被标记的对象就是可以回收的。 标记清除算法 标记整理算法 复制算法 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"Java基础知识/JVM内存排查.html":{"url":"Java基础知识/JVM内存排查.html","title":"JVM问题排查","keywords":"","body":"JVM问题排查 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/并发编程.html":{"url":"简介/并发编程.html","title":"并发编程","keywords":"","body":"并发编程 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/设计模式.html":{"url":"简介/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"简介/面经总结.html":{"url":"简介/面经总结.html","title":"面经总结","keywords":"","body":"面经总结 hashmap的底层数据结构，put的过程。 JDK1.7 ,HashMap底层是数据和链表结合在一起使用，也就是链表散列 JDK1.8 ,HashMap底层是数据和链表和红黑树结合一起使用 jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 put过程 Hashmap是否是线程安全的，多线程下会有什么问题？concurrentHashMap底层是如何实现线程安全的。 HashMap不是线程安全的，HashTable 和concurrentHashMap是线程安全的，HashTable 是全局锁，HashTable容器使用synchronized来保证线程安全，concurrentHashMap分段锁，性能更高。 HashMap在多线程下会出现死循环问题 原因：HashMap出现死循环的条件是，当两个线程同时对原有的旧的Hash表扩容时，当其中一个线程正在扩容时（遍历单向链表）切换到另外一个线程进行扩容操作，并且在线程二中完成了所有的扩容操作，此时再切换到线程1中就可能造成单向链表形成一个环，从而在下一次查询操作时就可能发生死循环。 concurrentHashMap底层是如何实现线程安全的？ ConcurrentHashMap采用的是分段式锁，可以理解为把一个大的Map拆封成N个小的Segment，在put数据时会根据hash来确定具体存放在哪个Segment中，Segment内部的同步机制是基于ReentryLock操作的，每一个Segment都会分配一把锁，当线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，也就是实现并发访问。 能说一下ConcurrentHashMap在JDK1.7和JDK1.8中的区别吗？ JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点） JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了 JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档 synchronized实现原理与锁的升级过程。 锁的升级过程 升级过程简单理解为： 偏向锁 -> 轻量级锁 -> 重量级锁 synchronized实现原理 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取。 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。 在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 数据库是否用了索引？用explain无法看出索引用了哪一部分？ 遇到非等值判断时匹配停止 a = ? and b = ? and c= ? a = ? and b = ? and c > ? a = ? and b > ? and c > ?， 只用到索引的一部分(a,b)，因为b把数据阻断了，b不是定植时，c时无序的，无法使用(a,b,c)索引 spring循环引用的问题，A->B->A问题,怎么解决 Spring 为了解决单例的循环依赖问题，使用了三级缓存。其中一级缓存为单例池（singletonObjects），二级缓存为提前曝光对象（earlySingletonObjects），三级缓存为提前曝光对象工厂（singletonFactories）。 假设A、B循环引用，实例化 A 的时候就将其放入三级缓存中，接着填充属性的时候，发现依赖了 B，同样的流程也是实例化后放入三级缓存，接着去填充属性时又发现自己依赖 A，这时候从缓存中查找到早期暴露的 A，没有 AOP 代理的话，直接将 A 的原始对象注入 B，完成 B 的初始化后，进行属性填充和初始化，这时候 B 完成后，就去完成剩下的 A 的步骤，如果有 AOP 代理，就进行 AOP 处理获取代理后的对象 A，注入 B，走剩下的流程。 举个不用回表的例子 回表：数据库根据索引找到了指定的记录所在行后，还需要根据rowid再次到数据块里取数据的操作。 比如：select code from order where mcode = ‘M001’;因为mcode索引，所以查询mcode的索引，查到符合要求的数据的rowid(索引内是不会保存具体数据的)，再根据rowid，查询到具体的数据，拿到code。 如何避免回表 使用覆盖索引。 使用mcode的索引，使用(mcode,code)的联合索引。 在查找到mcode的索引后，可以直接拿到code了，不需要再回表。 Mysql主键用uuid会有什么问题？ 主键一般使用 mysql的自增主键、uuid、雪花算法。 自增主键：减少了页分裂和碎片的产生 效率最高 uuid: uuid毫无规律、新增的值不一定比之前的主键值大，所以innodb无法总数将新行插入到索引的最后 ① 写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO ②因为写入是乱序的，innodb不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，一次插入最少需要修改三个页以上 ③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片 聚蔟索引和非聚蔟索引的区别，是否分别对应主键索引、辅助索引？ 是的 聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据. 非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置. jvm垃圾回收是如何做的？ 标记清除算法 ，产生内存碎片 标记整理算法 ，GC暂停时间会加长 复制算法， 内存空间使用率只有50%，可分配内存减少了一半 分代收集算法，分为eden和survivor区， Survivor 由 FromSpace与ToSpace组成，新生代复制算法来完成收集，老年代使用用“标记-清除”算法或“标记-整理”算法来进行回收。 特别地，在分代收集算法中，对象的存储具有以下特点： 对象优先在 Eden 区分配。 大对象直接进入老年代。 长期存活的对象将进入老年代，默认为 15 岁。 jvm运行时有哪些数据区 程序计数器：记录程序执行的位置，有了程序计数器，就可以保证在涉及线程上下文切换的情景下，程序依然能够正确无误地运行下去。 Java虚拟机栈：存着程序运行时的局部变量，主要包含局部变量表、操作数栈。 本地方法栈：为native方法服务 方法区：线程共享，用于存储类的元信息、静态变量、常量、全局变量、普通方法的字节码等内容。 堆：线程共享、存储实例对象和数组 java垃圾回收器有哪些 Serial(串行GC)收集器 ... ParNew(并行GC)收集器 ... Parallel Scavenge(并行回收GC)收集器 ... Serial Old(串行GC)收集器 ... Parallel Old(并行GC)收集器 ... CMS(并发GC)收集器 ... G1收集器 哈希冲突如何解决 开放寻址法，冲突则根据指定步长向后寻找直到找到空位或没有位置。 再哈希发，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，等哈希函数 直到不再冲突。 建立公共溢出区， 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 ，缺点: 如未能命中哈希表 需要遍历查找溢出表 查询效率低。 拉链法 ，如出现冲突，将其作为链表一个节点加入头或者尾巴处。 b+树叶子节点存的是指针吗？存的是数据 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"面经总结/面试总结1.html":{"url":"面经总结/面试总结1.html","title":"面试总结1","keywords":"","body":"面经总结 hashmap的底层数据结构，put的过程。 JDK1.7 ,HashMap底层是数据和链表结合在一起使用，也就是链表散列 JDK1.8 ,HashMap底层是数据和链表和红黑树结合一起使用 jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 put过程 Hashmap是否是线程安全的，多线程下会有什么问题？concurrentHashMap底层是如何实现线程安全的。 HashMap不是线程安全的，HashTable 和concurrentHashMap是线程安全的，HashTable 是全局锁，HashTable容器使用synchronized来保证线程安全，concurrentHashMap分段锁，性能更高。 HashMap在多线程下会出现死循环问题 原因：HashMap出现死循环的条件是，当两个线程同时对原有的旧的Hash表扩容时，当其中一个线程正在扩容时（遍历单向链表）切换到另外一个线程进行扩容操作，并且在线程二中完成了所有的扩容操作，此时再切换到线程1中就可能造成单向链表形成一个环，从而在下一次查询操作时就可能发生死循环。 concurrentHashMap底层是如何实现线程安全的？ ConcurrentHashMap采用的是分段式锁，可以理解为把一个大的Map拆封成N个小的Segment，在put数据时会根据hash来确定具体存放在哪个Segment中，Segment内部的同步机制是基于ReentryLock操作的，每一个Segment都会分配一把锁，当线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，也就是实现并发访问。 能说一下ConcurrentHashMap在JDK1.7和JDK1.8中的区别吗？ JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点） JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了 JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档 synchronized实现原理与锁的升级过程。 锁的升级过程 升级过程简单理解为： 偏向锁 -> 轻量级锁 -> 重量级锁 synchronized实现原理 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取。 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。 在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 数据库是否用了索引？用explain无法看出索引用了哪一部分？ 遇到非等值判断时匹配停止 a = ? and b = ? and c= ? a = ? and b = ? and c > ? a = ? and b > ? and c > ?， 只用到索引的一部分(a,b)，因为b把数据阻断了，b不是定植时，c时无序的，无法使用(a,b,c)索引 spring循环引用的问题，A->B->A问题,怎么解决 Spring 为了解决单例的循环依赖问题，使用了三级缓存。其中一级缓存为单例池（singletonObjects），二级缓存为提前曝光对象（earlySingletonObjects），三级缓存为提前曝光对象工厂（singletonFactories）。 假设A、B循环引用，实例化 A 的时候就将其放入三级缓存中，接着填充属性的时候，发现依赖了 B，同样的流程也是实例化后放入三级缓存，接着去填充属性时又发现自己依赖 A，这时候从缓存中查找到早期暴露的 A，没有 AOP 代理的话，直接将 A 的原始对象注入 B，完成 B 的初始化后，进行属性填充和初始化，这时候 B 完成后，就去完成剩下的 A 的步骤，如果有 AOP 代理，就进行 AOP 处理获取代理后的对象 A，注入 B，走剩下的流程。 举个不用回表的例子 回表：数据库根据索引找到了指定的记录所在行后，还需要根据rowid再次到数据块里取数据的操作。 比如：select code from order where mcode = ‘M001’;因为mcode索引，所以查询mcode的索引，查到符合要求的数据的rowid(索引内是不会保存具体数据的)，再根据rowid，查询到具体的数据，拿到code。 如何避免回表 使用覆盖索引。 使用mcode的索引，使用(mcode,code)的联合索引。 在查找到mcode的索引后，可以直接拿到code了，不需要再回表。 Mysql主键用uuid会有什么问题？ 主键一般使用 mysql的自增主键、uuid、雪花算法。 自增主键：减少了页分裂和碎片的产生 效率最高 uuid: uuid毫无规律、新增的值不一定比之前的主键值大，所以innodb无法总数将新行插入到索引的最后 ① 写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO ②因为写入是乱序的，innodb不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，一次插入最少需要修改三个页以上 ③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片 聚蔟索引和非聚蔟索引的区别，是否分别对应主键索引、辅助索引？ 是的 聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据. 非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置. jvm垃圾回收是如何做的？ 标记清除算法 ，产生内存碎片 标记整理算法 ，GC暂停时间会加长 复制算法， 内存空间使用率只有50%，可分配内存减少了一半 分代收集算法，分为eden和survivor区， Survivor 由 FromSpace与ToSpace组成，新生代复制算法来完成收集，老年代使用用“标记-清除”算法或“标记-整理”算法来进行回收。 特别地，在分代收集算法中，对象的存储具有以下特点： 对象优先在 Eden 区分配。 大对象直接进入老年代。 长期存活的对象将进入老年代，默认为 15 岁。 jvm运行时有哪些数据区 程序计数器：记录程序执行的位置，有了程序计数器，就可以保证在涉及线程上下文切换的情景下，程序依然能够正确无误地运行下去。 Java虚拟机栈：存着程序运行时的局部变量，主要包含局部变量表、操作数栈。 本地方法栈：为native方法服务 方法区：线程共享，用于存储类的元信息、静态变量、常量、全局变量、普通方法的字节码等内容。 堆：线程共享、存储实例对象和数组 java垃圾回收器有哪些 Serial(串行GC)收集器 ... ParNew(并行GC)收集器 ... Parallel Scavenge(并行回收GC)收集器 ... Serial Old(串行GC)收集器 ... Parallel Old(并行GC)收集器 ... CMS(并发GC)收集器 ... G1收集器 哈希冲突如何解决 开放寻址法，冲突则根据指定步长向后寻找直到找到空位或没有位置。 再哈希发，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，等哈希函数 直到不再冲突。 建立公共溢出区， 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 ，缺点: 如未能命中哈希表 需要遍历查找溢出表 查询效率低。 拉链法 ，如出现冲突，将其作为链表一个节点加入头或者尾巴处。 b+树叶子节点存的是指针吗？存的是数据 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"面经总结/面试总结2.html":{"url":"面经总结/面试总结2.html","title":"面试总结2","keywords":"","body":"面试总结2 cms的原理，是否发生stop the world，有什么缺点 cms(Concurrent Mark Sweep) 收集器是一种以获取最短停顿时间为目标的收集器，是基于标记清除的算法实现的。 整个垃圾回收过程有四步 初始标记：标记一下GC Roots 能直接关联的对象，速度很快 （stop the world） 并发标记：并发标记是从GCRoot开始继续向下进行标记 重新标记：修正在并发标记过程中发生变化的标记 (stop the world) 并发清除：标记清除算法，清除老年代中的垃圾 整个垃圾回收过程中耗时最长的并发标记和并发清除过程收集器线程和用户线程一起工作，并发执行。 CMS收集器的优点：并发收集、低停顿。 CMS收集器的缺点： CMS收集器对CPU资源非常敏感：由于收集器线程(最耗时的并发标记和并发清除)和用户线程并发执行，收集器占用一部分线程、cpu导致应用程序变慢。 CMS处理器无法处理浮动垃圾： 并发清理阶段用户线程还在运行，收集器标记后，用户线程产生了新的垃圾，CMS无法在本次进行处理，只能等待下一次gc处理。 CMS基于标记清除算法会产生内存碎片：空间碎片过多会给大对象分配带来麻烦，可能会提前触发Full GC. 老年代垃圾回收放不下了，会发生什么。 此时就会直接触发-次\"FullGC\" , 就是对老年代进行垃圾回收,尽量腾出来-些内存空间,然后再执行Minor GC. Full GC就是对老年代进行垃圾回收,同时也一般会对新生代进行垃圾回收 如果要是Full GC过后, 老年代还是没有足够的空间存放Minor GC过后的剩余存活对象,那么此时就会导致所谓的\"OOM\"内存溢出了 老年代用标记的主要原因是什么。 标记垃圾，如果使用复制算法，需要两倍的空间，而且需要复制很多存活的对象，老年代对象存活时间久。 数据库sql的执行过程 一条更新语句的执行过程 一条查询语句的执行过程 sql执行顺序 索引为什么用b+树，而不是用b树，为什么不用红黑树。 B+树只有叶子节点存储数据，其余节点用来索引，B-树每个节点都有Data域，增到了节点大小，增加了磁盘IO次数。B+树相对于B树磁盘IO次数少。 B+树相对于B树查询性能稳定，所有数据都在叶子节点，B树不稳定，数据在根节点和叶子节点分散，效率会不一样。 B+树支持范围查询，B+树的所有叶子节点用指针串起来了，遍历节点就能获取所有数据，可以进行区间查询。 AVL树和红黑树基本都是存储在内存中才会使用的数据结构，mysql数据是存在磁盘的，红黑树是二叉搜索树，深度太深，磁盘IO次数太多，效率低下 innodb和myisam中索引的区别。 存储结构：InnoDB是聚集索引，数据文件是和（主键）索引绑在一起的，即索引 + 数据 = 整个表数据文件。MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针 锁：myisam使用的是表锁、innodb使用的是行锁。 事务：myisam不支持事务与MVVC,InnoDB支持事务与MVVC 主键：myisam允许没有任何索引和主键的表存在，InnoDB如果没有设定主键或非空唯一索引，会自动生成主键。 外键：myisam不支持外键，innodb支持。 spring aop的原理。cglib和jdk动态代理的原理，有什么区别。为什么jdk动态代理不继承类。 数据库的隔离级别，可重复读是否解决了幻读的问题，发生幻读举个例子。mysql怎么解决幻读的问题。 读未提交：也就是允许读到未提交的内容，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。 读已提交：读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于RDBMS中常见的默认隔离级别（比如说Oracle和SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在SQL查询的时候编写带加锁的SQL语句。 可重复读：保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL默认的隔离级别就是可重复读。 串行化：将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。 可重复读无法解决幻读问题，串行化可以解决幻读问题。 mysql有哪些锁。mvcc怎么实现。当前读怎么操作。 线程池有哪些参数。默认的拒绝策略有哪些。最大线程数有什么用。 ThreadPoolExecutor类可设置的参数主要有： int corePoolSize: 线程池的核心线程数 int maximumPoolSize: 线程池的最大线程数 long keepAliveTime: 当线程数大于核心数时，多余的空闲线程等待新任务的存活时候 TimeUtil unit: keepAliveTime: 的时间单位 ThreadFactory threadFactory: 线程工厂 BlockingQueue workQueue： 用来存储等待执行任务的队列 RejectedExecutionHandler handler： 拒绝策略 拒绝策略： AbortPolicy(默认) ：丢弃任务并抛出RejectedExecutionException CallerRunsPolicy：由调用线程处理该任务。(例如io操作，线程消费速度没有NIO快，可能导致阻塞队列一直增加，此时可以使用这个模式) DiscardPolicy：丢弃任务，但是不抛出异常。 （可以配合这种模式进行自定义的处理方式） iscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务（重复执行） 强引用、软引用、弱引用、虚引用有什么区别。 强引用： Object obj = new Object()中的obj就是强引用，只要强引用还存在，垃圾回收器就永远不会回收调此类对象，JVM宁愿抛出OutOfMemoryError. 弱引用：只有当JVM认为内存不足，在内存即将发生内存溢出之前，才会回收，软引用可用来实现内存敏感的高速缓存。 软引用: 软引用关联的对象只能存活到下一次垃圾收集发生之前，无论内存是否足够，都会回收。 虚引用：垃圾回收时收到一个系统通知。 threadlocal用过么，原理是什么。 Threadlocal底层是通过threadlocalMap进行存储键值 每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。 ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 ThreadLocal 和Synchonized 两者都是解决多线程并发访问，Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离，Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享 ThreadLocal提供了线程本地变量，ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。 © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"面经总结/面试总结3.html":{"url":"面经总结/面试总结3.html","title":"面试总结3","keywords":"","body":"面试总结3 java类加载过程是怎么样的 加载->验证->准备->解析->初始化->使用->卸载 说一下volatile 保证内存可见性与禁止指令重排序 使用缓存一致性协议保证内存可见性，当CPU对变量进行写操作时发现，变量是共享变量，那么就会通知其他CPU中将该变量的缓存行设置为无效状态。 当其他CPU在操作变量时发现此变量在的缓存行已经无效，那么就会去主内存中重新读取最新的变量，通过嗅探总线传播数据。 使用内存屏障禁止指令重排序 数据库慢查询优化了解哪些 建索引的几大原则： 最左前缀匹配原则：mysql会一直向右匹配直到遇到范围查询(>、 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序 尽量选择区分度高的列作为索引。 索引列不能参与计算，保持列“干净 ，函数不走索引 尽量的扩展索引，不要新建索引 慢查询优化步骤： 先运行看看是否真的很慢，注意设置SQL_NO_CACHE where条件单表查，锁定最小返回记录表，这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高，找出区分度最高的字段。 explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询） order by limit 形式的sql语句让排序的表优先查 了解业务方使用场景 加索引时参照建索引的几大原则 观察结果，不符合预期继续从0分析 有遇到过内存泄漏吗？你们是怎么解决的？ © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "},"面经总结/面试总结4.html":{"url":"面经总结/面试总结4.html","title":"面试总结4","keywords":"","body":"面试总结4 String为什么要是final类型的 给一个已有字符串\"abcd\"第二次赋值成\"abcedl\"，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址 String本质是个char数组，而且用final关键字修饰，这说明String不可继承。 反射机制的底层实现是什么？动态呢？动态的实现原理？ © gaohueric all right reserved，powered by Gitbook文件修订时间： 2021-12-08 23:22:22 "}}
#  **题目描述（中等难度）**

> **[warning] [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)**

![](https://github.com/gaohueric/blogpicture/raw/master/%E6%88%AA%E5%B1%8F2021-05-03%2022.13.45.png)

# 解法一:递归

递归遍历二叉树，统计节点个数

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
     List<Integer> list = new ArrayList<>();
     preOrder(root,list);
     return list.size();
    }

    public void preOrder(TreeNode root,List<Integer> list){
        if(root == null){
            return;
        }
        list.add(root.val);
        preOrder(root.left,list);
        preOrder(root.right,list);
    }
}

```

简单递归实现

```java
public int countNodes(TreeNode root) {
    if (root == null){
        return 0;
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}

```

#解法二：迭代

使用栈进行迭代
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
      List<Integer> res = new ArrayList<>();
      Deque<TreeNode> deque = new ArrayDeque<>();
      while(!deque.isEmpty() || root != null){
          while(root != null){
              res.add(root.val);
              deque.offerLast(root);
              root = root.left;
          }
         root =  deque.pollLast();
         root = root.right;
      }
      return res.size();
    }
}
```

递归与迭代时间复杂度不太理想，进阶采用更快的时间复杂度解决。




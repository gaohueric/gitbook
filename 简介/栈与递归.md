# 栈与递归刷题顺序

| 题目分类             | 题目编号         |
| -------------------- | ---------------- |
| 用栈访问最后若干元素 | 682、71、388     |
| 栈与计算器           | 150、227、224    |
| 栈与括号匹配         | 20、636、591、32 |
| 递归                 | 385、341、394    |

# 栈与队列知识总结

## 栈的基本概念

关于“栈”，有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。**后进者先出，先进者后出，这就是典型的“栈”结构。**

从栈的操作特性上来看，**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。

**当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构**。

**栈在函数中的应用**：栈在函数中的应用、栈在表达式中应用(括号匹配)、栈实现浏览器的前进与后退功能等

## 栈的实现

栈的实现主要有两种，一种是数组的实现，叫做**顺序栈**，另外一种是链表的实现，叫做**链式栈**

### 顺序栈

使用数组实现栈

```java

/**
 * 功能:基于数组的顺序栈
 * @author gaohu08299
 * @create $ ID: ArrayStack, 2021-05-05 11:07 gaohu08299 Exp $
 * @since 1.0.0
 */
public class ArrayStack {
    private String[] items;  // 数组
    private int count;       // 栈中元素个数
    private int n;           // 栈的大小

    // 初始化数组，申请一个大小为 n 的数组空间
    public ArrayStack(int n) {
        this.items = new String[n];
        this.n = n;
        this.count = 0;
    }

    /**
     * 功能:入栈
     * 说明:数组入栈的入口为数组尾部
     *
     * @param item :入栈数据元素
     * @return:是否入栈成功
     */
    public boolean push(String item) {
        // 数组空间不够了，直接返回 false，入栈失败。
        if (count == n) return false;
        // 将 item 放到下标为 count 的位置
        items[count] = item;
        //数组长度+1
        ++count;
        //入栈成功
        return true;
    }

    /**
     * 功能:出栈
     *
     * @return:返回出栈元素
     */
    public String pop() {
        // 栈为空，则直接返回 null
        if (count == 0) return null;
        // 返回下标为 count-1 的数组元素
        String tmp = items[count - 1];
        //数组长度-1
        --count;
        //返回出栈数据元素
        return tmp;
    }
}

```




### 链式栈

```java
/**
 * 功能:基本链表实现栈，入栈、出栈、输出栈
 *
*/
public class StackBasedLinkedList {
    //定义栈顶指针
    private Node top = null;

    //定义栈结点
    private static class Node {
        //栈结点数据域
        private int data;
        //栈结点指针域
        private Node next;

        //构造函数
        public Node(int data, Node next) {
            this.data = data;
            this.next = next;
        }

        //get 获取数据域方法
        public int getData() {
            return data;
        }
    }

    /**
     * @param value:要入栈的数据元素
     */
    public void push(int value) {
        //创建一个栈结点
        Node newNode = new Node(value, null);
        // 判断栈是否为空
        if (top == null) {
            //如果栈为空，就将入栈的值作为栈的第一个元素
            top = newNode;
        } else {
            //否则插入到top栈结点前（所谓的就是单链表的头插法）
            newNode.next = top;
            top = newNode;
        }
    }

    /**
     * 功能 : 出栈
     *
     * @return: -1 为栈中没有数据
     */
    public int pop() {
        // 如果栈的最顶层栈结点为null,栈为空
        if (top == null) return -1;

        //否则执行出栈操作，现将栈顶结点的数据元素赋值给 Value
        int value = top.data;
        //将 top 指针向下移动
        top = top.next;
        //返回出栈的值
        return value;
    }

    /**
     * 功能:输出栈中所有元素
     */
    public void printAll() {
        //将栈顶指针赋值给p
        Node p = top;
        //循环遍历栈(遍历单链表)
        while (p != null) {
            System.out.print(p.data + " ");
            //指向下一个结点
            p = p.next;
        }

    }
}
```











